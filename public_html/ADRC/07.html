<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="it" xml:lang="it">
<head>
<!-- 2021-11-10 mer 23:10 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ADRC - Lesson 07</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Alessandro Straziota" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" href="/appunti.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="/"> HOME </a>
</div><div id="content">
<h1 class="title">ADRC - Lesson 07</h1>
<div id="table-of-contents">
<h2>Indice</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgc6c3176">1. Spanning tree construction</a></li>
<li><a href="#org7a8c93f">2. Single Source Shout Protocol</a>
<ul>
<li><a href="#orge50cd3d">2.1. Terminazione del protocollo</a></li>
<li><a href="#org5a2e072">2.2. Correttezza</a></li>
<li><a href="#orga22891a">2.3. Message complexity</a></li>
</ul>
</li>
</ul>
</div>
</div>


<div id="outline-container-orgc6c3176" class="outline-2">
<h2 id="orgc6c3176"><span class="section-number-2">1</span> Spanning tree construction</h2>
<div class="outline-text-2" id="text-1">
<p>
Uno <b>spanning tree</b>, o <b>albero ricoprente</b>, è un sottoinsieme di archi \(T \subseteq E\) tale che
il grafo \(G=(V,T)\) risulta essere <b>connesso</b> e <b>aciclico</b>.<br />
</p>

<p>
Come visto per il protocollo di broadcast, è spesso utile riuscire a calcolare uno spanning tree
su una rete in maniera <i>distribuita</i>.
</p>

<p>
La definizione di tale problema è la seguente
</p>
<ul class="org-ul">
<li><b>Assunzioni</b>:
<ul class="org-ul">
<li><b>Single initiator</b> esiste un solo nodo che in risposta ad uno stimolo esterno o spontaneamente avvia il protocollo.</li>
<li><b>Bidirectional links</b> il grafo di rete è non diretto</li>
<li><b>Total reliability</b> si ha certezza che un messaggio trasmesso su un arco arriva sempre a destinazione in un tempo finito
e senza errori</li>
<li><b>Connectivity</b> il grafo di rete \(G\) è connesso</li>
</ul></li>
<li><b>Configurazione iniziale</b>: ogni nodo \(x \in V\) conserva un sottoinsieme di vicini denominato con \(\texttt{tree-neig}(x)\),
che rappresenta i relativi vicini nello <i>spanning tree</i>. Inizialmente tale insieme è <i>inizializzato</i> come vuoto \(\texttt{tree-neig}(x) = \lbrace \rbrace\).</li>
<li><b>Configurazione finale</b>: uno stato in cui tutti i nodi hanno nell'insieme \(\texttt{tree-neig}(x)\) tutti e soli i nodi
vicini nello spanning tree ricavato dal protocollo.</li>
</ul>
</div>
</div>

<div id="outline-container-org7a8c93f" class="outline-2">
<h2 id="org7a8c93f"><span class="section-number-2">2</span> Single Source Shout Protocol</h2>
<div class="outline-text-2" id="text-2">
<p>
Immedesimandosi in un generico nodo \(x\) ci si può chiedere:
</p>
<blockquote>
<p>
come decido chi saranno i miei vicini nello spanning tree?
</p>
</blockquote>
<p>
Semplicemente basta <i>chiedere</i> ai propri vicini se appartengono già allo spanning tree che si sta costruendo,
e in base alla risposta agire di conseguenza:
</p>
<ul class="org-ul">
<li>se il nodo già appartiene allo spanning tree allora lo si scarta.</li>
<li>se il nodo ancora non appartiene allora gli si propone se vuole diventare un nodo <i>figlio</i>.</li>
</ul>

<p>
In generale potrebbe capitare che un nodo riceva molteplici richieste di diventare nodo figlio, però
semplicemente può rispondere <code>YES</code> alla prima proposta, e <code>NO</code> a tutte le altre.<br />
</p>

<p>
Per ridurre ulteriormente il numero di messaggi, quando il nodo \(x\) diventa parte dello spanning tree,
manda in broadcast a tutti i suoi vicini (eccetto al nodo padre) la proposta di diventare nodo figlio.<br />
</p>


<div class="figure">
<p><img src="../images/adrc-lesson07-img1.png" alt="adrc-lesson07-img1.png" style="max-width:200px width:100%" />
</p>
<p><span class="figure-number">Figura 1: </span>Spontaneamente la sorgente avvia il protocollo</p>
</div>


<div class="figure">
<p><img src="../images/adrc-lesson07-img2.png" alt="adrc-lesson07-img2.png" style="max-width:400px width:100%" />
</p>
<p><span class="figure-number">Figura 2: </span>Possibili situazioni</p>
</div>

<p>
Definiamo quindi l'insieme degli stati del processo
</p>
\begin{align*}
S &= \lbrace \texttt{INIT}, \texttt{IDLE}, \texttt{ACTIVE}, \texttt{DONE} \rbrace\\
S_{init} &= \lbrace \texttt{INIT}, \texttt{IDLE} \rbrace\\
S_{final} &= \lbrace \texttt{DONE} \rbrace
\end{align*}

<div class="org-src-container">
<pre class="src src-python">if self.state == "INIT":
    spontaneusly:
	self.root = True
	self.tree_neig = {}
	send(Q) to self.neighbors
	self.counter = 0
	self.state = "ACTIVE"

if self.state == "IDLE":
    receiving(Q):
	self.root = False
	self.parent = Q.sender
	self.tree_neig = {Q.sender}
	send("YES") to Q.sender
	self.counter = 1

	if self.counter == len(self.neighbors):
	    self.state = "DONE"
	else:
	    send(Q) to self.neighbors - {Q.sender}
	    self.state = "ACTIVE"

if self.state == "ACTIVE":
    receiving(Q):
	send("NO") to Q.sender
    receiving(R):

	if R.msg == "YES":
	    self.tree_neig = self.tree_neig + {R.sender}
	    self.counter += 1  
	elif R.msg == "NO":
	    self.counter += 1

	if self.counter == len(self.neighbors):
		self.state == "DONE"

if self.stat == "DONE":
    None
</pre>
</div>
<p align="center"><span class="figure-number">Code 1:</span> Pseudocodice python-like del protocollo Shout/p>
</div>

<div id="outline-container-orge50cd3d" class="outline-3">
<h3 id="orge50cd3d"><span class="section-number-3">2.1</span> Terminazione del protocollo</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Il protocollo <code>Shout</code> è molto simile al protocollo <code>Flood</code>, con l'aggiunta di messaggi di <i>feedback</i> <code>YES/NO</code>.
Dato che siamo sotto l'assunzione che \(G\) è connesso, allora certamente ogni nodo \(x\) (eccetto la sorgente) riceverà almeno una richiesta <code>Q</code> di diventare figlio.
Perciò ogni nodo nello stato <code>IDLE</code> passerà allo stato <code>ACTIVE</code>, con il proprio contatore pari a 1.
Per <span class="underline">ogni richiesta</span> ricevuta tutti i nodi risponderanno <code>YES</code> o <code>NO</code>.
Dato che prima di entrare nello stato <code>DONE</code> un nodo deve ricevere una risposta da tutti i vicini, e dato che per costruizione tutti rispondono alle richieste
allora prima o poi tutti i nodi passerranno dallo stato <code>ACTIVE</code> allo stato <code>DONE</code>, terminando localmente il proprio task.<br />
</p>
</div>
</div>

<div id="outline-container-org5a2e072" class="outline-3">
<h3 id="org5a2e072"><span class="section-number-3">2.2</span> Correttezza</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Si vuole dimostrare che l'unione di tutti i \(\texttt{tree-neig}(x)\) è uno <i>spanning tree</i> per la rete \(G\).<br />
</p>

<p>
Per prima cosa bisogna dimostrare le <b>coerenza</b> degli insiemi \(\texttt{tree-neig}(x)\), ovvero che \(x\) ha come vicino \(y\) nello spanning tree (\(y \in \texttt{tree-neig}(x)\))
allora anche \(x\) deve risultare essere vicino di \(y\) (\(x \in \texttt{tree-neig}(y)\)).
Questo è facilmente verificabile: certamente uno tra \(x\) e \(y\) deve necessariamente essere il nodo padre, supponiamo \(x\) senza perdita di generalità.
Dato che \(y \in \texttt{tree-neig}(x)\), e dato che stiamo assumendo che \(y\) è figlio di \(x\), allora vuol dire che \(y\) avrà risposto <code>YES</code> alla proposta di \(x\), e per
costruzione del protocollo \(x\) che è nello stato <code>ACTIVE</code> aggiungerà \(y\) nel suo vicinato.
Contrariamente se \(y\) ha risposto <code>YES</code> vuol dire che era nello stato <code>IDLE</code>, e che la prima richiesta ricevuta è stata quella di \(x\).
Per costruzione del protocollo, \(y\) contra \(x\) come nodo padre, e lo aggiungerà nel suo vicinato.<br />
</p>

<p>
A questo punto è necessario dimostrare che l'unione di tutti i \(\texttt{tree-neig}(x)\) è <b>connesso</b>.
Anche questo è banalmente verificabile dal fatto che ogni nodo \(x\) (eccetto la sorgente) è collegato al proprio genitore tramite una sequenza di <i>YES-links</i>
che risale fino alla sorgente.
Perciò data una qualsiasi coppia di nodi \(x,y\), essi saranno connessi dal cammino \(x \leadsto s \leadsto y\), dove \(s\) è il nodo sorgente.<br />
</p>

<p>
Infine non resta che dimostrare che il grafo risultante dal protocollo è <b>aciclico</b>.
Questo si può inferire dal fatto che ogni nodo (eccetto la sorgente) invia <b>una sola</b> risposta <code>YES</code>, la quale permetterà al nodo di "appendersi" all'albero.
Supponiamo quindi <i>per assurdo</i> che da nodo \(x\) esistano due cammini semplici distinti fino alla sorgente \(s\) che formano un ciclo.
Anche se i dui cammini possono iniziare "scendendo" di livello, dato che entrambi i cammini <b>risalgono</b> alla sorgente
allora certamente da un certo punto in poi passeranno per un arco che parte da un nodo figlio verso un nodo padre salendo di livello.
Consideriamo solo uno dei due lati del ciclo (tanto il ragionamento è simmetrico).
Supponiamo che il primo arco del cammino che risale di livello è un certo \((a,b)\), dove \(b\) è genitore di \(a\).
Dato \((a,b)\) è il primo arco <i>risalente</i>, vuol dire che prima di prendere \((a,b)\) si è scesi di livello con tutti archi del tipo <code>PADRE-&gt;FIGLIO</code>.
Però sappiamo che ogni nodo ha un <b>singolo</b> nodo padre, perciò per arrivare ad \(a\) certamente si sarà preso l'arco \((b,a)\).
Questo però non può accadere in quanto nei cammini semplici non si può ripercorrere due volte uno stesso arco, perciò entrambi i lati dell'ipotetico ciclo
devono necessariamente partire \(x\) a <b>risalire</b>.
Ma dato che <b>x</b> ha un solo padre allora esiste un solo cammino (<i>risalente</i>) da \(x\) alla sorgente \(s\).
</p>
</div>
</div>


<div id="outline-container-orga22891a" class="outline-3">
<h3 id="orga22891a"><span class="section-number-3">2.3</span> Message complexity</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Come accennato in precedenza il protocollo <code>Shout</code> è una sorta di protocollo <code>Flood</code> con l'aggiunta di messaggi di <i>feedback</i>.
Perciò si può intuire che la message complexity del protocollo <code>Shout</code> è due volte quella del protocollo <code>Flood</code>.
\[
   MSG(\texttt{SHOUT}) = 2 \cdot MSG(\texttt{FLOOD})
   \]
Andiamo però a fare un'analisi più dettagliata per verificare l'intuizione.<br />
</p>

<p>
Consideriamo che i messaggi che passano sugli archi sono del tipo <code>Q</code>, di richiesta di diventare figlio, e di tipo <code>R</code>, di risposta, il quale a sua
volta può essere di tipo <code>YES</code> o <code>NO</code>.
Si vuole quindi contare per ogni tipologia di messaggi <code>Q</code>, <code>YES</code>, <code>NO</code> quanti ne vengono trasmessi per ogni arco.<br />
</p>

<p>
Iniziamo però considerando quali situazioni è possibbile che accadano e quali no:
</p>
</div>
<ol class="org-ol">
<li><a id="org9fbe00b"></a><b>Casi possibili</b><br />
<div class="outline-text-5" id="text-2-3-0-1">
<ul class="org-ul">
<li>caso <code>Q-YES</code>, ovvero nel caso in cui su di un arco passa prima una proposta <code>Q</code> e poi la risposta <code>YES</code>.</li>
<li>caso <code>Q-Q</code>, quando due nodi vicini passano nello stato active (<sub>quasi</sub>_) simultaneamente e si scambiano reciporcamente una proposta <code>Q</code>.</li>
<li>caso <code>NO-NO</code>, diretta conseguenza del caso precedente.</li>
</ul>
</div>
</li>
<li><a id="org60623bd"></a><b>Casi impossibili</b><br />
<div class="outline-text-5" id="text-2-3-0-2">
<ul class="org-ul">
<li>caso <code>NO-YES</code>, non può accadere in quanto il nodo sinistro per rispondere <code>NO</code> deve prima aver ricevuto una richiesta dal nodo destro, il quale avrà già
un padre e quindi non può rispondere nuovamente <code>YES</code>.</li>
<li>caso <code>YES-YES</code>, per inviarsi reciprocamente il messaggio <code>YES</code>, vuol dire che entrambe le estremità dell'arco hanno inviato il messaggio <code>Q</code>, ma ciò implica
che hanno già un padre e che quindi hanno già inviato <code>YES</code> a un altro nodo.</li>
</ul>


<div class="figure">
<p><img src="../images/adrc-lesson07-img3.png" alt="adrc-lesson07-img3.png" style="max-width:400px width:100%" />
</p>
</div>


<p>
Contiamo ora quanti messaggi vengono scambiati per ogni caso possibile
</p>
</div>
</li>
<li><a id="org3eb8c65"></a><code>Q</code> <b>messages :</b><br />
<div class="outline-text-5" id="text-2-3-0-3">
<p>
Il messaggio <code>Q</code> viene inviato nei casi <code>Q-YES</code> e <code>Q-Q</code>.
Il caso <code>Q-YES</code> accade esattamente una volta per ogni nodo eccetto la sorgente, ovvero \(n-1\) volte.
Il caso <code>Q-Q</code> accade su tutti gli archi del vicinato di un nodo eccetto che per l'arco per il quale il nodo è diventato figlio (ovviamente escludendo la sorgente).
Perciò avremo \(m\) archi meno un arco per ogni nodo esclusa la sorgente, ovvero meno \(n-1\) archi.
Perciò in totale verranno scambiati \(2(m - (n-1)) - (n-1) = 2m - n + 1\) messaggi di tipo <code>Q</code>.
</p>

<p>
<b>[da finire]</b>
</p>
</div>
</li>
</ol>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Data: 2021-10-28 gio 00:00</p>
<p class="author">Autore: Alessandro Straziota</p>
<p class="email">Email: <a href="mailto:alessandrostr95@gmail.com">alessandrostr95@gmail.com</a></p>
<p class="date">Created: 2021-11-10 mer 23:10</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
