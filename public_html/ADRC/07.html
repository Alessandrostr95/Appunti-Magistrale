<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="it" xml:lang="it">
<head>
<!-- 2021-11-15 lun 14:18 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ADRC - Lesson 07</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Alessandro Straziota" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" href="/appunti.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="/"> HOME </a>
</div><div id="content">
<h1 class="title">ADRC - Lesson 07</h1>
<div id="table-of-contents">
<h2>Indice</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org1c080d6">1. Spanning tree construction</a></li>
<li><a href="#org603f86b">2. Single Source Shout Protocol</a>
<ul>
<li><a href="#org59b5904">2.1. Terminazione del protocollo</a></li>
<li><a href="#org245a482">2.2. Correttezza</a></li>
<li><a href="#org638dd2e">2.3. Message complexity</a></li>
<li><a href="#orgd841daf">2.4. Ottimizzazione - Protocollo <code>Shout+</code></a></li>
</ul>
</li>
<li><a href="#org62bdea8">3. Depth First Traversal (DFT) Protocol</a>
<ul>
<li><a href="#orga8e66f9">3.1. Message complexity</a></li>
<li><a href="#orgc55b5c1">3.2. Time complexity</a></li>
<li><a href="#org472fcba">3.3. Ottimizzazione</a>
<ul>
<li><a href="#org1421d50">3.3.1. Complexity</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org6470f7d">4. Multiple Sources Spanning Tree Construction</a></li>
</ul>
</div>
</div>


<div id="outline-container-org1c080d6" class="outline-2">
<h2 id="org1c080d6"><span class="section-number-2">1</span> Spanning tree construction</h2>
<div class="outline-text-2" id="text-1">
<p>
Uno <b>spanning tree</b>, o <b>albero ricoprente</b>, è un sottoinsieme di archi \(T \subseteq E\) tale che
il grafo \(G=(V,T)\) risulta essere <b>connesso</b> e <b>aciclico</b>.<br />
</p>

<p>
Come visto per il protocollo di broadcast, è spesso utile riuscire a calcolare uno spanning tree
su una rete in maniera <i>distribuita</i>.
</p>

<p>
La definizione di tale problema è la seguente
</p>
<ul class="org-ul">
<li><b>Assunzioni</b>:
<ul class="org-ul">
<li><b>Single initiator</b> esiste un solo nodo che in risposta ad uno stimolo esterno o spontaneamente avvia il protocollo.</li>
<li><b>Bidirectional links</b> il grafo di rete è non diretto</li>
<li><b>Total reliability</b> si ha certezza che un messaggio trasmesso su un arco arriva sempre a destinazione in un tempo finito
e senza errori</li>
<li><b>Connectivity</b> il grafo di rete \(G\) è connesso</li>
</ul></li>
<li><b>Configurazione iniziale</b>: ogni nodo \(x \in V\) conserva un sottoinsieme di vicini denominato con \(\texttt{tree-neig}(x)\),
che rappresenta i relativi vicini nello <i>spanning tree</i>. Inizialmente tale insieme è <i>inizializzato</i> come vuoto \(\texttt{tree-neig}(x) = \lbrace \rbrace\).</li>
<li><b>Configurazione finale</b>: uno stato in cui tutti i nodi hanno nell'insieme \(\texttt{tree-neig}(x)\) tutti e soli i nodi
vicini nello spanning tree ricavato dal protocollo.</li>
</ul>

<hr />
</div>
</div>

<div id="outline-container-org603f86b" class="outline-2">
<h2 id="org603f86b"><span class="section-number-2">2</span> Single Source Shout Protocol</h2>
<div class="outline-text-2" id="text-2">
<p>
Immedesimandosi in un generico nodo \(x\) ci si può chiedere:
</p>
<blockquote>
<p>
come decido chi saranno i miei vicini nello spanning tree?
</p>
</blockquote>
<p>
Semplicemente basta <i>chiedere</i> ai propri vicini se appartengono già allo spanning tree che si sta costruendo,
e in base alla risposta agire di conseguenza:
</p>
<ul class="org-ul">
<li>se il nodo già appartiene allo spanning tree allora lo si scarta.</li>
<li>se il nodo ancora non appartiene allora gli si propone se vuole diventare un nodo <i>figlio</i>.</li>
</ul>

<p>
In generale potrebbe capitare che un nodo riceva molteplici richieste di diventare nodo figlio, però
semplicemente può rispondere <code>YES</code> alla prima proposta, e <code>NO</code> a tutte le altre.<br />
</p>

<p>
Per ridurre ulteriormente il numero di messaggi, quando il nodo \(x\) diventa parte dello spanning tree,
manda in broadcast a tutti i suoi vicini (eccetto al nodo padre) la proposta di diventare nodo figlio.<br />
</p>


<div class="figure">
<p><img src="../images/adrc-lesson07-img1.png" alt="adrc-lesson07-img1.png" style="max-width:200px; width:100%" />
</p>
<p><span class="figure-number">Figura 1: </span>Spontaneamente la sorgente avvia il protocollo</p>
</div>


<div class="figure">
<p><img src="../images/adrc-lesson07-img2.png" alt="adrc-lesson07-img2.png" style="max-width:400px; width:100%" />
</p>
<p><span class="figure-number">Figura 2: </span>Possibili situazioni</p>
</div>

<p>
Definiamo quindi l'insieme degli stati del processo
</p>
\begin{align*}
S &= \lbrace \texttt{INIT}, \texttt{IDLE}, \texttt{ACTIVE}, \texttt{DONE} \rbrace\\
S_{init} &= \lbrace \texttt{INIT}, \texttt{IDLE} \rbrace\\
S_{final} &= \lbrace \texttt{DONE} \rbrace
\end{align*}

<div class="org-src-container">
<pre class="src src-python">if self.state == "INIT":
    spontaneusly:
	self.root = True
	self.tree_neig = {}
	send(Q) to self.neighbors
	self.counter = 0
	self.state = "ACTIVE"

if self.state == "IDLE":
    receiving(Q):
	self.root = False
	self.parent = Q.sender
	self.tree_neig = {Q.sender}
	send("YES") to Q.sender
	self.counter = 1

	if self.counter == len(self.neighbors):
	    self.state = "DONE"
	else:
	    send(Q) to self.neighbors - {Q.sender}
	    self.state = "ACTIVE"

if self.state == "ACTIVE":
    receiving(Q):
	send("NO") to Q.sender
    receiving(R):

	if R.msg == "YES":
	    self.tree_neig = self.tree_neig + {R.sender}
	    self.counter += 1  
	elif R.msg == "NO":
	    self.counter += 1

	if self.counter == len(self.neighbors):
		self.state == "DONE"

if self.stat == "DONE":
    None
</pre>
</div>
<p align="center"><span class="figure-number">Code 1:</span> Pseudocodice python-like del protocollo Shout</p>
</div>

<div id="outline-container-org59b5904" class="outline-3">
<h3 id="org59b5904"><span class="section-number-3">2.1</span> Terminazione del protocollo</h3>
<div class="outline-text-3" id="text-2-1">
<p>
Il protocollo <code>Shout</code> è molto simile al protocollo <code>Flood</code>, con l'aggiunta di messaggi di <i>feedback</i> <code>YES/NO</code>.
Dato che siamo sotto l'assunzione che \(G\) è connesso, allora certamente ogni nodo \(x\) (eccetto la sorgente) riceverà almeno una richiesta <code>Q</code> di diventare figlio.
Perciò ogni nodo nello stato <code>IDLE</code> passerà allo stato <code>ACTIVE</code>, con il proprio contatore pari a 1.
Per <span class="underline">ogni richiesta</span> ricevuta tutti i nodi risponderanno <code>YES</code> o <code>NO</code>.
Dato che prima di entrare nello stato <code>DONE</code> un nodo deve ricevere una risposta da tutti i vicini, e dato che per costruizione tutti rispondono alle richieste
allora prima o poi tutti i nodi passerranno dallo stato <code>ACTIVE</code> allo stato <code>DONE</code>, terminando localmente il proprio task.<br />
</p>
</div>
</div>

<div id="outline-container-org245a482" class="outline-3">
<h3 id="org245a482"><span class="section-number-3">2.2</span> Correttezza</h3>
<div class="outline-text-3" id="text-2-2">
<p>
Si vuole dimostrare che l'unione di tutti i \(\texttt{tree-neig}(x)\) è uno <i>spanning tree</i> per la rete \(G\).<br />
</p>

<p>
Per prima cosa bisogna dimostrare le <b>coerenza</b> degli insiemi \(\texttt{tree-neig}(x)\), ovvero che \(x\) ha come vicino \(y\) nello spanning tree (\(y \in \texttt{tree-neig}(x)\))
allora anche \(x\) deve risultare essere vicino di \(y\) (\(x \in \texttt{tree-neig}(y)\)).
Questo è facilmente verificabile: certamente uno tra \(x\) e \(y\) deve necessariamente essere il nodo padre, supponiamo \(x\) senza perdita di generalità.
Dato che \(y \in \texttt{tree-neig}(x)\), e dato che stiamo assumendo che \(y\) è figlio di \(x\), allora vuol dire che \(y\) avrà risposto <code>YES</code> alla proposta di \(x\), e per
costruzione del protocollo \(x\) che è nello stato <code>ACTIVE</code> aggiungerà \(y\) nel suo vicinato.
Contrariamente se \(y\) ha risposto <code>YES</code> vuol dire che era nello stato <code>IDLE</code>, e che la prima richiesta ricevuta è stata quella di \(x\).
Per costruzione del protocollo, \(y\) contra \(x\) come nodo padre, e lo aggiungerà nel suo vicinato.<br />
</p>

<p>
A questo punto è necessario dimostrare che l'unione di tutti i \(\texttt{tree-neig}(x)\) è <b>connesso</b>.
Anche questo è banalmente verificabile dal fatto che ogni nodo \(x\) (eccetto la sorgente) è collegato al proprio genitore tramite una sequenza di <i>YES-links</i>
che risale fino alla sorgente.
Perciò data una qualsiasi coppia di nodi \(x,y\), essi saranno connessi dal cammino \(x \leadsto s \leadsto y\), dove \(s\) è il nodo sorgente.<br />
</p>

<p>
Infine non resta che dimostrare che il grafo risultante dal protocollo è <b>aciclico</b>.
Questo si può inferire dal fatto che ogni nodo (eccetto la sorgente) invia <b>una sola</b> risposta <code>YES</code>, la quale permetterà al nodo di "appendersi" all'albero.
Supponiamo quindi <i>per assurdo</i> che da nodo \(x\) esistano due cammini semplici distinti fino alla sorgente \(s\) che formano un ciclo.
Anche se i dui cammini possono iniziare "scendendo" di livello, dato che entrambi i cammini <b>risalgono</b> alla sorgente
allora certamente da un certo punto in poi passeranno per un arco che parte da un nodo figlio verso un nodo padre salendo di livello.
Consideriamo solo uno dei due lati del ciclo (tanto il ragionamento è simmetrico).
Supponiamo che il primo arco del cammino che risale di livello è un certo \((a,b)\), dove \(b\) è genitore di \(a\).
Dato \((a,b)\) è il primo arco <i>risalente</i>, vuol dire che prima di prendere \((a,b)\) si è scesi di livello con tutti archi del tipo <code>PADRE-&gt;FIGLIO</code>.
Però sappiamo che ogni nodo ha un <b>singolo</b> nodo padre, perciò per arrivare ad \(a\) certamente si sarà preso l'arco \((b,a)\).
Questo però non può accadere in quanto nei cammini semplici non si può ripercorrere due volte uno stesso arco, perciò entrambi i lati dell'ipotetico ciclo
devono necessariamente partire \(x\) a <b>risalire</b>.
Ma dato che <b>x</b> ha un solo padre allora esiste un solo cammino (<i>risalente</i>) da \(x\) alla sorgente \(s\).
</p>
</div>
</div>


<div id="outline-container-org638dd2e" class="outline-3">
<h3 id="org638dd2e"><span class="section-number-3">2.3</span> Message complexity</h3>
<div class="outline-text-3" id="text-2-3">
<p>
Come accennato in precedenza il protocollo <code>Shout</code> è una sorta di protocollo <code>Flood</code> con l'aggiunta di messaggi di <i>feedback</i>.
Perciò si può intuire che la message complexity del protocollo <code>Shout</code> è due volte quella del protocollo <code>Flood</code>.
\[
   MSG(\texttt{SHOUT}) = 2 \cdot MSG(\texttt{FLOOD})
   \]
Andiamo però a fare un'analisi più dettagliata per verificare l'intuizione.<br />
</p>

<p>
Consideriamo che i messaggi che passano sugli archi sono del tipo <code>Q</code>, di richiesta di diventare figlio, e di tipo <code>R</code>, di risposta, il quale a sua
volta può essere di tipo <code>YES</code> o <code>NO</code>.
Si vuole quindi contare per ogni tipologia di messaggi <code>Q</code>, <code>YES</code>, <code>NO</code> quanti ne vengono trasmessi per ogni arco.<br />
</p>

<p>
Iniziamo però considerando quali situazioni è possibbile che accadano e quali no:
</p>
</div>
<ol class="org-ol">
<li><a id="org10f69b9"></a><b>Casi possibili</b><br />
<div class="outline-text-5" id="text-2-3-0-1">
<ul class="org-ul">
<li>caso <code>Q-YES</code>, ovvero nel caso in cui su di un arco passa prima una proposta <code>Q</code> e poi la risposta <code>YES</code>.</li>
<li>caso <code>Q-Q</code>, quando due nodi vicini passano nello stato active e si scambiano reciporcamente una proposta <code>Q</code>.</li>
<li>caso <code>NO-NO</code>, diretta conseguenza del caso precedente.</li>
</ul>
</div>
</li>
<li><a id="org6868867"></a><b>Casi impossibili</b><br />
<div class="outline-text-5" id="text-2-3-0-2">
<ul class="org-ul">
<li>caso <code>NO-YES</code>, non può accadere in quanto il nodo sinistro per rispondere <code>NO</code> deve prima aver ricevuto una richiesta dal nodo destro, il quale avrà già
un padre e quindi non può rispondere nuovamente <code>YES</code>.</li>
<li>caso <code>YES-YES</code>, per inviarsi reciprocamente il messaggio <code>YES</code>, vuol dire che entrambe le estremità dell'arco hanno inviato il messaggio <code>Q</code>, ma ciò implica
che hanno già un padre e che quindi hanno già inviato <code>YES</code> a un altro nodo.</li>
</ul>


<div class="figure">
<p><img src="../images/adrc-lesson07-img3.png" alt="adrc-lesson07-img3.png" style="max-width:400px width:100%" />
</p>
</div>


<p>
Contiamo ora quanti messaggi vengono scambiati per ogni caso possibile
</p>
</div>
</li>
<li><a id="orgdb5c0f1"></a><code>Q</code> <b>messages:</b><br />
<div class="outline-text-5" id="text-2-3-0-3">
<p>
il messaggio <code>Q</code> viene inviato nei casi <code>Q-YES</code> e <code>Q-Q</code>.
Il caso <code>Q-YES</code> accade esattamente una volta per ogni nodo eccetto la sorgente, ovvero \(n-1\) volte.
Il caso <code>Q-Q</code> accade su tutti gli archi del vicinato di un nodo eccetto che per l'arco per il quale il nodo è diventato figlio (ovviamente escludendo la sorgente).
Perciò avremo \(m\) archi, meno un arco per ogni nodo esclusa la sorgente, ovvero meno \(n-1\) archi.
Perciò in totale verranno scambiati \(2(m - (n-1)) - (n-1) = 2m - n + 1\) messaggi di tipo <code>Q</code>.
</p>
</div>
</li>

<li><a id="org669bb0b"></a><code>YES</code> <b>messages:</b><br />
<div class="outline-text-5" id="text-2-3-0-4">
<p>
il messaggio di tipo <code>YES</code> viene scambiato solamente nella situazione <code>Q-YES</code>, per un totale di \(n-1\) volte.
</p>
</div>
</li>

<li><a id="org1771a8c"></a><code>NO</code> <b>messages:</b><br />
<div class="outline-text-5" id="text-2-3-0-5">
<p>
il messaggio di tipo <code>NO</code> viene trasmesso per due volte nella situazione <code>NO-NO</code>, ovvero di conseguenza al caso <code>Q-Q</code>,
per un totale di \(2(m - (n - 1))\).
</p>

<p>
La message complexity del protocollo <code>Shout</code> sarà la somma dei precedenti valori
</p>
\begin{align*}
MSG(\texttt{SHOUT}) &= (2m - n + 1) + (n - 1) + (2m - 2(n - 1))\\
&= 4m - 2n + 2 = 2(2m - n + 1)\\
&= 2 \cdot MSG(\texttt{FLOOD})
\end{align*}
</div>
</li>
</ol>
</div>


<div id="outline-container-orgd841daf" class="outline-3">
<h3 id="orgd841daf"><span class="section-number-3">2.4</span> Ottimizzazione - Protocollo <code>Shout+</code></h3>
<div class="outline-text-3" id="text-2-4">
<p>
È possibile abbattere il fattore \(4\) dalla complessità del protocollo <code>Shout</code> semplicemente facendo la seguente osservazione:
lo scambio di messaggi di tipo <code>NO</code> sono in realtà <i>superflui</i>, se un nodo \(x\) riceve una proposta <code>Q</code> da un nodo \(y\) allora certamente
\(y\) è nello stato <code>ACTIVE</code>, e quindi avrà già un nodo padre, perciò è inutile che \(x\) mandi una proposta ad \(y\).
Perciò ricevere un messaggio <code>Q</code> può essere interpretato come la ricezione di un messaggio <code>NO</code> dalla stessa porta.<br />
</p>

<div class="org-src-container">
<pre class="src src-python">if self.state == "INIT":
    spontaneusly:
	self.root = True
	self.tree_neig = {}
	send(Q) to self.neighbors
	self.counter = 0
	self.state = "ACTIVE"

if self.state == "IDLE":
    receiving(Q):
	self.root = False
	self.parent = Q.sender
	self.tree_neig = {Q.sender}
	send("YES") to Q.sender
	self.counter = 1

	if self.counter == len(self.neighbors):
	    self.state = "DONE"
	else:
	    send(Q) to self.neighbors - {Q.sender}
	    self.state = "ACTIVE"

if self.state == "ACTIVE":
    receiving(Q):
	self.counter += 1
	if self.counter == len(self.neighbors):
		self.state == "DONE"

    receiving("YES"):
	self.tree_neig = self.tree_neig + {R.sender}
	self.counter += 1  
	if self.counter == len(self.neighbors):
		self.state == "DONE"

if self.stat == "DONE":
    None
</pre>
</div>
<p align="center"><span class="figure-number">Code 2:</span> Pseudocodice python-like del protocollo Shout+</p>

<p>
Per quanto riguarda la <i>message complexity</i> del nuovo protocollo ottimizzato basta osservare che non può mai accadere la situazione <code>NO-NO</code>, ovvero
quando su un arco verrà trasmesso due volte il messaggio <code>NO</code>.
Perciò la message complexity del protocollo <code>Shout+</code> sarà
\[
   MSG(\texttt{SHOUT+}) = MSG(\texttt{SHOUT}) - 2(m - (n - 1)) = 2m 
   \]
</p>

<p>
Riguardo invece la terminazione locale del protocollo, ogni nodo sa che il suo compito è terminato nel momento in cui passa allo stato <code>DONE</code>.
Sarebbe interessante sapere se un nodo è in grado di capire quando il processo termina <i>globalmente</i>.
Certamente se la sorgente \(s\) è in grado di sapere quando lo spanning tree è completato, allora potrebbe mandare una notifica in broadcast per avvertire tutti gli altri.
Il problema è che non ogni nodo ha solamente una <b>visione locale</b> della rete in cui si trova, perciò a meno che non ci sia un nodo che riesca ad osservare lo stato della
rete dall'alto non è possibile sapere solo col protocollo <code>Shout</code> se il processo di costruzione dello spanning tree è terminato.<br />
</p>

<p>
<b>OSS.1</b> si può ottimizzare ulteriormente il protocollo in modo da abbattere il fattore \(\Omega(m)\)?
La risposta è <b>no</b>. Semplicemente perché per costruire uno spanning tree bisogna informare <span class="underline">in broadcast</span> tutti i nodi della rete quantomeno che il protocollo è iniziato.
Se fosse possibile farlo, allora avremmo trovato anche un protocollo di broadcast che esegue il suo task in tempo \(< m\), e sappiamo che non è possibile sotto
tali assunzioni (<code>BL</code>, <code>UI</code>, <code>C</code>, <code>TR</code>).<br />
</p>

<p>
<b>THM</b> l'esecuzione del protocollo di broadcast genera uno <i>spanning tree</i> <b>entrante</b><sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> della rete.<br />
<b>Proof:</b> basta semplicemente che ogni nodo \(x\) conservi come variabile \(father(x)\) il nodo dal quale per primo ha ricevuto l'informazione.
</p>

<p>
<b>OSS.2</b> Si può osservare che lo <i>spanning tree</i> costruito con il protocollo <code>Shout</code> (o con la sua versione ottimizzata) dipende fortemente
dalla singola esecuzione e non dal protocollo, in quanto i ritardi di trasmissione variano ogni volta.
Ciò implica che maneggiando adeguatamente i ritardi di trasmissione potrebbe accadere che \(diam(\texttt{SPT}) >> diam(G)\).<br />
</p>

<p>
In base a quest'ultima osservazione si potrebbe voler cercare di costruire uno spanning tree con diametro non troppo maggiore del diametro dell'intera rete.
</p>
<hr />
</div>
</div>
</div>

<div id="outline-container-org62bdea8" class="outline-2">
<h2 id="org62bdea8"><span class="section-number-2">3</span> Depth First Traversal (DFT) Protocol</h2>
<div class="outline-text-2" id="text-3">
<p>
Consideriamo un problema in cui un <i>nodo iniziale</i> possiede un <b>token</b>, e di volere che questo token (non replicabile) venga passato tra <b>tutti</b> i nodi della rete.
In pratica si tratterebbe di fare un broadcast del token, senza però l'opportunita di duplicare il token e di inviarlo a più vicini contemporaneamente.<br />
</p>

<p>
Il protocollo <code>Depth First Traversal</code> (d'ora in poi definito con <code>DFT</code>) permette di risolvere questo problema eseguendo una <a href="https://en.wikipedia.org/wiki/Depth-first_search">visita in profondità</a>,
generando così uno spanning tree della rete.<br />
</p>

<p>
L'idea del protocollo è la seguente:
</p>
<ol class="org-ol">
<li>quando un nodo \(x\) riceve per la <span class="underline">prima volta</span> il token da un nodo \(y\), \(x\) deve ricordarsi che \(y\) è il suo padre bello spanning tree e poi
deve inviare <span class="underline">ad uno</span> dei suoi vicini (eccetto \(y\)) il token, aspettando che ritorni indietro (<code>reply</code>).</li>
<li>quando un nodo \(x\) che è già stato <i>visitato</i> riceve di nuovo il token lo rispedisce indietro al mittente specificando che è già stato visitato,
contrassegnando l'arco di ritorno come <code>back-edge</code>.</li>
<li>quando un nodo \(x\) riceve il token indietro da \(z\), verifica se è un <code>back-edge</code> e in tal caso può affermare che \(z\) non sarà un suo vicino nello spanning tree.
Se invece la risposta è solamente il token (senza specificare <code>back-edge</code>) allora \(x\) sa che \(z\) è un suo figlio nello spanning tree.
Dopodiché \(x\) inoltrerà il token ad un altro dei suoi vicini.</li>
<li>quando \(x\) avrà ricevuto indietro il token da tutti i suoi vicini lo inoltrerà nuovamente al padre.</li>
</ol>

<p>
Notare che il protocollo appena descritto è l'equivalente distribuita della visita in profondità ricorsiva, in cui la visita sul nodo \(x\) termina quando
sarà terminata la vista in profondità su tutti i suoi vicini (eccetto che per il nodo padre).
Il protocollo terminerà nel momento in cui la sorgente \(s\) avrà ricevuto il token indietro da tutti i suoi vicini.<br />
</p>


<div class="figure">
<p><img src="../images/adrc-lesson07-img4.png" alt="adrc-lesson07-img4.png" style="max-width:200px; width:100%" />
</p>
</div>
</div>

<div id="outline-container-orga8e66f9" class="outline-3">
<h3 id="orga8e66f9"><span class="section-number-3">3.1</span> Message complexity</h3>
<div class="outline-text-3" id="text-3-1">
<p>
Osservare che esistono tre tipologie di messaggi:
</p>
<ol class="org-ol">
<li><code>token</code> quando un nodo inoltre il token per procedere con la visita.</li>
<li><code>back</code> quando un nodo già visitato restituisce il token al mittente.</li>
<li><code>return</code> quando un nodo termina la propria visita è restituisce indietro il token al padre.</li>
</ol>
<p>
inoltre su ogni arco può passare solamente uno tra i messaggi <code>back</code> e <code>return</code>, mentre il messaggio di tipo <code>token</code> passa esattamente una volta su tutti gli archi.
Perciò la message complexity è esattamente \(2m \in \Theta(m)\).
Ricordiamo sempre che esiste un teorema che dimostra che, sotto le assunzioni in questione, non è possibile eseguire il broadcasting di una informazione in meno
di \(m\) messaggi, e dato che in questo caso sostanzialmente si sta facendo il broadcast del token, un lowerbound alla message complexity rimane \(\Omega(m)\).
</p>
</div>
</div>

<div id="outline-container-orgc55b5c1" class="outline-3">
<h3 id="orgc55b5c1"><span class="section-number-3">3.2</span> Time complexity</h3>
<div class="outline-text-3" id="text-3-2">
<p>
Anche se il protocollo è asincrono ha senso parlare di <i>time complexity</i>, in quanto lo scambio di messaggi avviene in maniera <b>totalmente sequenziale</b><sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>.
Perciò la time complexity è proporzionale alla message complexity.
</p>
</div>
</div>

<div id="outline-container-org472fcba" class="outline-3">
<h3 id="org472fcba"><span class="section-number-3">3.3</span> Ottimizzazione</h3>
<div class="outline-text-3" id="text-3-3">
<p>
Osserviamo che in grafi molto densi una larga quantità di messaggi risolverà in messaggi di tipo <code>back</code>.
Perciò sarebbe ideale cercare di evitare che questo accada.<br />
</p>

<p>
Un'idea è quella di far inviare una notifica a tutto il vicinato di \(x\) qual'ora \(x\) riceva il token per la prima volta (eccetto che al nodo padre, ovviamente).
Così facendo, tutti i vicini sapranno che \(x\) è già stato informato e non ci sarà più bisogno in futuro di ritrasmettergli il token, evitando così i messaggi di
tipo <code>back</code>.<br />
</p>

<p>
Il grosso vantaggio, dal punto di vista temporale, è che \(x\) può mandare la notifica ai suoi vicini in maniera <b>parallela</b>.<br />
</p>

<p>
Prima di proseguire all'inoltro del token, è <b>necessario</b> però che \(x\) riceva un <code>ACK</code><sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup> dal suo vicinato, in quanto disponendo in modo adeguato i ritardi
di trasmissione, potrebbe capitare che un suo vicino \(y\) riceva il token prima del messaggio di notifica, reinviando così nuovamente il token a \(x\).
In tale situazione non avremmo risolto nulla, in quanto \(x\) dovrebbe rispedire il token ad \(y\) con un messaggio di <code>back</code>.<br />
</p>
</div>

<div id="outline-container-org1421d50" class="outline-4">
<h4 id="org1421d50"><span class="section-number-4">3.3.1</span> Complexity</h4>
<div class="outline-text-4" id="text-3-3-1">
<p>
In questa ottimizzazione i tipi di messaggi scambiati sono:
</p>
<ol class="org-ol">
<li><code>token</code> quando un nodo inoltre il token per procedere con la visita.</li>
<li><code>visited</code> quando un nodo che ha appena ricevuto il token notifica i suoi vicini.</li>
<li><code>ack</code> la risposta di avvenuta notifica da parte dei vicini.</li>
<li><code>return</code> quando un nodo termina la propria visita è restituisce indietro il token al padre.</li>
</ol>

<p>
Ogni nodo (eccetto la sorgente \(s\)) ricerà il <code>token</code> una sola volta, e inoltre invierà il messaggio di <code>return</code> una sola volta, per un totale
di \(2(n-1)\) messaggi.<br />
</p>

<p>
Per quanto riguarda il messaggio di notifica <code>visited</code>, ogni nodo lo invierà a tutto il suo vicinato meno che al nodo da cui hanno ricevuto il token.
La sorgente sarà l'unico nodo che invierà la notifica a tutto il suo vicinato
</p>
\begin{align*}
msg(\texttt{visited})
&= |N(s)| + \sum_{v \in V \setminus \lbrace s \rbrace} |N(v)| - 1\\
&= |N(s)| + \sum_{v \in V \setminus \lbrace s \rbrace} |N(v)| -  \sum_{v \in V \setminus \lbrace s \rbrace} 1\\
&= \sum_{v \in V} |N(v)| -  \sum_{v \in V \setminus \lbrace s \rbrace} 1\\
&= 2m - (n - 1)
\end{align*}

<p>
Inoltre per ogni notifica <code>visited</code> corrisponde una risposta <code>ack</code>, quindi la message complexity sarà
</p>
\begin{align*}
  MSG(\texttt{DFT+})
  &= 2(n-1) + 2(2m - (n-1))\\
  &= 2(n-1) + 4m - 2(n-1)\\
  &= 4m\\
  &= 2 \cdot MSG(\texttt{DFT})
\end{align*}
<p>
ovvero il doppio del protocollo con messaggi di tipo <code>back</code>.<br />
</p>

<p>
Come già accennato il vantaggio sta nella time complexity.
Infatti sappiamo che possiamo mandare i messaggi di notifica in parallelo, inoltre se il sistema è <i>sincrono</i> riceveremo i messaggi di <code>ack</code> nello stesso momento.
In un sistema sincrono in cui (senza perdita di generalità) tutti i messaggi sono trasmessi in una unità temporale, avremo che in soli due istanti (ovvero in tempo <b>costante</b>)
ogni nodo invierà le notifiche e riceverà le risposte.<br />
Perciò il tempo necessario al completamento del task sarà:
</p>
<ol class="org-ol">
<li>\(n-1\) per inviati di tipo <code>return</code>.</li>
<li>\(n-1\) perché ogni nodo eccetto la sorgente riceverà esattamente un messaggio <code>token</code>.</li>
<li>\(n\) perché ogni nodo invia le notifiche <code>visited</code> in parallelo ai suoi vicini.</li>
<li>\(n\) perché tutti i vicini di un nodo risponderanno in maniera sincrona con un <code>ack</code>.</li>
</ol>
<p>
per un totale di \(4n - 2\).<br />
</p>

<p>
Con questa ottimizzazione, anche se si "paga" un fattore 2 alla message complexity otteremo che la time complexity sara <b>lineare</b> in \(n\), e non più in \(m\).
Ciò implica un miglioramento non indifferente se si considerano casi in cui la rete è molto densa, ovvero quando \(m \in \Theta(n^2)\).
</p>

<hr />
</div>
</div>
</div>
</div>

<div id="outline-container-org6470f7d" class="outline-2">
<h2 id="org6470f7d"><span class="section-number-2">4</span> Multiple Sources Spanning Tree Construction</h2>
<div class="outline-text-2" id="text-4">
<p>
Rilassiamo l'ipotesi <code>Single Initiator</code> e consideriamo il problema più generale in cui esiste un insieme \(I \subseteq V\) di nodi <code>initiator</code>.<br />
</p>

<p>
<b>THM</b> sotto le sole assunzioni di <code>BL</code>, <code>C</code> e <code>TR</code> il problema della costruzione di spanning tree con multipli <code>initiator</code> non è deterministicamente risolvibile.<br />
</p>

<p>
<b>Proof:</b> consideriamo una clique di 3 nodi \(x,y,z\), tutti e tre <code>initiator</code>.
Consideriamo il caso <i>sincrono</i> in cui tutti si attivano e iniziano il protocollo al tempo \(t_0\).<br />
</p>

<p>
Dalle precedenti lezioni, sappiamo che presi dei nodi in uno stesso <i>stato interno</i> \(\sigma(v,t)\), allora essi da quel momento in poi si comporteranno alla stessa maniera,
dato che non sono in grado di distinguere una loro <i>identità</i> all'interno della rete.<br />
</p>

<p>
Assodato questo fatto, allora non si potrà <b>mai</b> arrivare in uno stato in cui un nodo è padre e gli altri due figli, in quanto questo implicherebbe
che uno dei nodi si è comportato in maniera differente dagli altri due (contrariamente all'osservazione precedente) \(\square\).<br />
</p>

<p>
Per risolvere questo problema è necessario risolvere un'altro problema: il problema della <b>leader election</b>.
Eletto un leader tra tutti i nodi <code>initiator</code>, esso potrà eseguire uno dei protocolli di costruzione di spanning tree a singola sorgente già noti.<br />
</p>

<p>
Vedremo in futuro che il problema della leader election può essere risolto in maniera deterministica solamente se i nodi sono <b>univocamente identificati</b>
in maniera globale.<br />
</p>

<hr />
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Note a pi&egrave; di pagina: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
ovvero dove ogni nodo possiede solamente informazioni su chi è il nodo padre, generando un albero con archi diretti "verso l'alto". 
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
non può mai accadere che due nodi distinti inviino messaggi nello stesso momento.
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
di conferma.
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="date">Data: 2021-10-28 gio 00:00</p>
<p class="author">Autore: Alessandro Straziota</p>
<p class="email">Email: <a href="mailto:alessandrostr95@gmail.com">alessandrostr95@gmail.com</a></p>
<p class="date">Created: 2021-11-15 lun 14:18</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
