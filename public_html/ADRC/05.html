<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="it" xml:lang="it">
<head>
<!-- 2021-11-14 dom 21:57 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ADRC - Lesson 05</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Alessandro Straziota" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" href="/appunti.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="/"> HOME </a>
</div><div id="content">
<h1 class="title">ADRC - Lesson 05</h1>
<div id="table-of-contents">
<h2>Indice</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org10db470">1. Labeled Hypercube</a>
<ul>
<li><a href="#orgcfdbadc">1.1. Hyperflood Protocoll</a>
<ul>
<li><a href="#orga428e2f">1.1.1. Correttezza</a></li>
<li><a href="#org0496377">1.1.2. Message Complexity</a></li>
<li><a href="#org14a3a85">1.1.3. Time complexity</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<hr />
<p>
I protocolli di broadcasting visti nelle precedenti lezioni risultano parecchio dispendiosi nel caso in cui vengano eseguiti in una rete <i>molto densa</i><sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>.
Nel caso limite in cui la rete sia una <i>clique</i><sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup>, il protocollo di <i>flooding</i> studiato ha una <i>message complexity</i> di \(\Theta(n^2)\).
Viceversa però, nel caso in cui la rete sia un <i>anello</i> o un <i>albero</i>, il protocollo è <b>ottimale</b>, ovvero verrà trasmesso un messaggio per ogni nodo, risultando
in una message complexity di \(\Theta(n)\).<br />
</p>

<p>
Una buona idea sarebbe quindi quella di <i>calcolare</i> uno <i><a href="https://it.wikipedia.org/wiki/Spanning_tree_(networking)">Spanning Tree</a></i> della rete, e di eseguire il protocollo di flooding con uno scambio di messaggi ottimale.
Precomputando lo spanning tree si potrebbe anche eseguire il protocollo tutte le volte che si desidera.
Un problemma non banale che occorre però è il calcolo di uno spanning tree in maniera distribuita.
Inoltre, pure assumendo di poter ottenere uno spanning tree con poche risorse, questa non è una struttura <b>stabile</b>.
Infatti, in una rete reale capita molto spesso che delle connessioni si interrompano, e se si rimuove un arco da una
rete con una struttura ad albero, essa verrà <i>disconnessa</i><sup><a id="fnr.3" class="footref" href="#fn.3">3</a></sup>.
In questo caso si dice la rete è <b>1-tollerant</b>.
In generale, un grafo si dice \(k\)-tollerant quando anche a fronte della rimozione di \(k\) archi, esso rimane connesso.
</p>

<hr />
<div id="outline-container-org10db470" class="outline-2">
<h2 id="org10db470"><span class="section-number-2">1</span> Labeled Hypercube</h2>
<div class="outline-text-2" id="text-1">
<p>
In questa sezione verrà studiato il problema del broadcasting su <i>ipercubi</i> e verrà mostrato come l'aggiunta della conoscenza della rete
da parte dei nodi, combintata alla simmetria della rete stessa, può portare alla creazione protocolli asintoticamente migliori del <i>Flooding</i>.<br />
</p>

<p>
Generalmente in un contesto reale si vuole costruire reti che abbiano le seguenti proprietà:
</p>
<ol class="org-ol">
<li>un <b>diametro</b> piccolo (\(O(1)\) o \(\texttt{poly-log}\)), in modo tale da ridurre i tempi di comunicazione tra i nodi.</li>
<li>il grafo deve essere <b>sparso</b>, risparmiando in termini di risorse per la creazione di link.</li>
</ol>
<p>
Si osservi che riducendo il grado massimo di un grafo, come conseguenza si otterrà la sua sparsificazione<sup><a id="fnr.4" class="footref" href="#fn.4">4</a></sup>.
Un'altro vantaggio di un grafo sparso è la sua <b>scalabilità</b>, ovvero la capacità di non comportare eccessivi costi nel caso di aggiunta di nuovo nodo.
Per esempio, una <i>clique</i> non è molto scalabile, in quanto ogni volta che viene aggiunto un nuovo nodo bisogna creare \(n - 1\) nuovi links.
Invece l'aggiunta di un nodo su un grafo a forma di <i>lista</i> comporta l'aggiunta di un solo arco.<br />
</p>

<p>
Non è tutto oro ciò che luccica: anche se un grafo a <i>lista</i> è estremamente scalabile e sparso, esso comporta alcuni cruciali svantaggi.
Il primo è che ha come diametro il valore massimo che si può presentare (\(n - 1\)).
Il secondo è la sua poca resistenza, infatti se si rompe anche solo un link il grafo si disconnette.
Contrariamente, una <i>clique</i> ha diametro minimo (ovvero 1) risultando in tempi di comunicazione ottimali.
In oltre prima di "rompersi" bisgona rimuovere almeno \(n - 1\) archi.<br />
</p>

<p>
Una struttura più equilibrata rispetto alle precedenti è la struttura a <b>griglia bidimensionale</b>.
In griglia di \(n\) nodi composta da \(\sqrt{n}\) righe e colonne, il grado massimo è 4, mentre il diametro è \(2 \sqrt{n}\).
Inoltre è abbastanza scalabile, infatti si possono collegare tra di loro più griglie semplicemento affiancandole e aggiungendo \(\sqrt{n}\) archi.
Anche se \(O(\sqrt{n})\) è un buon miglioramento rispetto a \(n\), si può ottenere di meglio.<br />
</p>

<p>
La struttura che offre un buon compromesso in termini di grado massimo, densità, resistenza, diamtero e scalabilità è l'<a href="https://en.wikipedia.org/wiki/Hypercube">ipercubo</a>.
È già noto che in un ipercubo \(d\)-dimensionale il numero di nodi è esattamente \(n = 2^d\), e di conseguenza \(d = \log_2{n}\).
Inoltre ogni nodo ha grado esattamente \(d\), quindi il numero complessivo di archi è \(m = \frac{nd}{2} = \frac{n\log_2{n}}{2}\).
</p>

<p>
Consideriamo il problema del broadcasting su un ipercubo:
oltre alle solite restrizioni già viste (<i>unique initiator</i>, <i>total reliability</i>, <i>bidirectional links</i> e <i>connectivity</i>), in questa variante
si assume che ogni nodo <span class="underline">sa</span> di essere in un <b>labeled hypercube</b> \(d\)-dimensionale.<br />
</p>

<p>
In questa particlare rete i <i>link</i> e i <i>nodi</i> sono etichettati come segue:
</p>
<ol class="org-ol">
<li>ogni nodo è <span class="underline">univocamente</span> eithcettato con una <b>stringa</b> in \(\lbrace 0, 1 \rbrace^d\).
Inoltre ogni nodo ha come vicino i nodi le quali etichette differiscono di <b>un solo</b> bit.</li>
<li>Ogni arco è etichettato con un numero nell'intervallo \(\left[ d \right]\), in modo che tale etichetta rappresenta l'indice del
bit per il quale i due nodi estremi differiscono (partendo a contare per esempio dal bit meno significativo).</li>
</ol>


<div class="figure">
<p><img src="../images/adrc-lesson05-img2.png" alt="adrc-lesson05-img2.png" width="200px" />
</p>
<p><span class="figure-number">Figura 1: </span>\(d = 1\)</p>
</div>


<div class="figure">
<p><img src="../images/adrc-lesson05-img3.png" alt="adrc-lesson05-img3.png" width="200px" />
</p>
<p><span class="figure-number">Figura 2: </span>\(d = 2\)</p>
</div>


<div class="figure">
<p><img src="../images/adrc-lesson05-img4.png" alt="adrc-lesson05-img4.png" width="200px" />
</p>
<p><span class="figure-number">Figura 3: </span>\(d = 3\)</p>
</div>

<p>
Si osservi che applicando semplicemente il protocollo <code>Flood</code> su questa rete la message complexity sarà \(O(n\log{n})\).<br />
</p>

<p>
Di seguito alcune definizioni utili
</p>

<p>
<b>DEF:</b> (<i>distanza di Hamming</i>) date due stringhe \(\overline{x},\overline{y} \in \lbrace 0,1 \rbrace^d\),
esse si dicono a distanza di <i>Hamming</i> \(d_{Ham}(\overline{x},\overline{y}) = k\) se le due stringhe 
differiscono esattamente di \(k\) simboli.
</p>

<p>
<b>DEF:</b>  (<i>Labeled Hypercube</i>) un ipercubo etichettato \(d\)-dimensionale \(H_d = (V, E)\) è un grafo il cui
insieme dei nodi è l'insieme \(V \equiv \lbrace \overline{x} \mid \overline{x} \in \lbrace 0,1 \rbrace^d \rbrace\),
mentre l'insieme degli archi è \(E \equiv \lbrace (\overline{x},\overline{y}) \in V^2 \mid d_{Ham}(\overline{x},\overline{y}) = 1 \rbrace\).
</p>

<p>
<b>Fact 1:</b> un ipercubo etichettato \(d\)-dimensionale \(H_d\) ha diametro esattamente \(d = \log_2{n}\).<br />
<b>Proof:</b> per dimostrare il fatto 1 è necessario dimostrare che per ogni coppia di nodi \(\overline{x},\overline{y} \in V\)
esiste un percorso \(P = \overline{x} \rightsquigarrow \overline{y}\) tale che la sua lunghezza \(|P|\) è minore uguale
di \(d\).<br />
</p>

<p>
Consideriamo quindi due differenti nodi \(\overline{x} = \langle x_1, x_2, ..., x_j, ..., x_d \rangle\) e
\(\overline{y} = \langle y_1, y_2, ..., y_j, ..., y_d \rangle\).
</p>

<p>
Scorrendo in parallelo i caratteri delle due stringhe, prima o poi si arriverà a un indice \(j_1\) tale che
\(x_{j_1} \neq y_{j_1}\) (perchè abbiamo assunto che \(\overline{x}\) e \(\overline{y}\) sono differenti).<br />
</p>

<p>
A questo punto, per costruzione dell'ipercubo etichettato, esisterà un suo vicino \(\overline{x}'\)
tale che  \(x'_{j_1} = y_{j_1}\).
Tale vicino sicurmanete esiste, dato che \(\overline{x}\) e \(\overline{x}'\) sono a <i>distanza di Hamming</i> 1.
Consideriamo quindi l'arco \((\overline{x}, \overline{x}')\) come primo arco del cammino \(P\).<br />
</p>

<p>
A questo punto, \(\forall i \leq j_1\) avremo che \(x'_i = y_i\), quindi partendo dall'indice \(j_1 + 1\) continuiamo
a scorrere in parallelo le due stringhe \(\overline{x}'\) e \(\overline{y}\).
Se arrivati all'indice \(d\) non si sono incontrati caratteri differenti, allora \(\overline{x}' = \overline{y}\), e quindi
il cammino è concluso.
Se invece \(\overline{x}' \neq \overline{y}\) certamente esisterà un indice \(j_1 < j_2 \leq d\) tale che \(x'_{j_2} \neq y_{j_2}\).<br />
</p>

<p>
Come prima, esisterà per forza un nodo \(\overline{x}''\) vicino di \(\overline{x}'\) tale che \(x''_{j_2} = y_{j_2}\).
Appendiamo quindi l'arco \((\overline{x}', \overline{x}'')\) al cammino.<br />
</p>

<p>
Proseguendo in questa maniera, prima o poi si arriverà ad un nodo \(\overline{x}^{\star} = \overline{y}\).
Nel cammino vengono considerati nodi a distanza di Hamming 1 l'uno dall'altro, e ad ogni arco preso ci si
"avvicina" di 1 alla destinazione.
Dato che al più \(\overline{x}\) è distnte \(d\) da \(\overline{y}\), allora il cammino costruito con il precedente metodo
può essere lungo al più \(d\) \(\square\).<br />
</p>


<p>
Un'altra caratteristica importante dell'ipercubo è la sua scalabilità.
Infatti si può estendere un ipercubo di dimensione \(d\) con un altro ipercubo di dimensione \(d\), semplicemente
aggiungendo un arco tra i nodi analoghi dei due ipercubi.
</p>


<div class="figure">
<p><img src="../images/adrc-lesson05-img1.gif" alt="adrc-lesson05-img1.gif" width="80%" />
</p>
<p><span class="figure-number">Figura 4: </span>Generazione Ipercubo</p>
</div>

<p>
Inoltre l'ipercubo è una struttura abbastanza stabile, in quanto per essere disconnessa è necessario rimuovere
almeno \(d\) archi.<br />
</p>

<p>
Di seguito un confornto tra le figure precedentemente descritte.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides" align="center">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Grafo</th>
<th scope="col" class="org-left">Diametro</th>
<th scope="col" class="org-left">Grado</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Clique</td>
<td class="org-left">\(\Theta(1)\)</td>
<td class="org-left">\(\Theta(n)\)</td>
</tr>

<tr>
<td class="org-left">Lista</td>
<td class="org-left">\(\Theta(n)\)</td>
<td class="org-left">\(\Theta(1)\)</td>
</tr>

<tr>
<td class="org-left">Griglia</td>
<td class="org-left">\(\Theta(\sqrt{n})\)</td>
<td class="org-left">\(\Theta(1)\)</td>
</tr>

<tr>
<td class="org-left">Ipercubo</td>
<td class="org-left">\(\Theta(\log{n})\)</td>
<td class="org-left">\(\Theta(\log{n})\)</td>
</tr>
</tbody>
</table>
</div>


<div id="outline-container-orgcfdbadc" class="outline-3">
<h3 id="orgcfdbadc"><span class="section-number-3">1.1</span> Hyperflood Protocoll</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Il protocollo <code>Hyperflood</code> è molto semplice, e sfrutta fortemente il fatto che i nodi posseggono delle conoscenze globali
della struttura della rete.
</p>

<p>
In maniera informale il protocollo funziona nella seguente maniera:
</p>
<ul class="org-ul">
<li>l'unico nodo <code>INITIATOR</code> invia il messaggio a tutti i suoi nodi vicini.</li>
<li>se un qualsiasi nodo riceve il messaggio da un arco etichettato con il numero \(\ell\), allora inoltrerà
il messaggio a tutti i suoi vicini connessi dagli archi con indice \(\ell' < \ell\).</li>
</ul>

<div class="org-src-container">
<pre class="src src-python">if self.status == "INITIATOR":
    spontaneously:
	send(self.message) to self.neighbors

else:
    recieving(message):
	 l = message.fromEdge
	 for i in range(1,l):
	     send(message) to self.neighbors[i]
</pre>
</div>

<p>
Questo protocollo può essere osservato in maniera <i>ricorsiva</i>.
Ovvero quando un nodo riceve il messaggio dall'arco \(\ell\) diventa l'<code>INITIATOR</code> del sotto-ipercubo di dimensione \(\ell' = \ell - 1\).
</p>
</div>

<div id="outline-container-orga428e2f" class="outline-4">
<h4 id="orga428e2f"><span class="section-number-4">1.1.1</span> Correttezza</h4>
<div class="outline-text-4" id="text-1-1-1">
<p>
Ciò che si vuole dimostrare è che ogni nodo dell'ipercubo viene informato.
Per prima cosa però è necessario enunciare è dimostrare il seguente lemma:
</p>

<p>
<b>Lemma 1</b> Per ogni coppia di nodi \(\overline{x},\overline{y}\) esiste sempre un cammino con <b>etichette decrescenti</b> da \(\overline{x}\) a \(\overline{y}\).
Nel protocollo <code>Hyperflood</code> il messaggio verrà inoltrato esattamente attraverso quel cammino.
</p>

<p>
<b>Proof:</b> consideriamo due nodi a caso \(\overline{x} = 100010100 \) e \(\overline{y} = 110001000 \).
Consideriamo la procedura per costruire un cammino usata nella dimostrazione del <b>Fact 1</b>, e consideriamo un ordinamento degli indici inverso (in senso decrescente
a partire da sinistra, per intenderci).<br />
Dato che i due nodi differiscono per i soli simboli in posizione \(8,5,4,3\), un cammino che li collega è composto dagli archi con etichette \(8,5,4,3\), ovvero
da archi con etichette decrescenti \(\square\).
</p>


<div class="figure">
<p><img src="../images/adrc-lesson05-img5.gif" alt="adrc-lesson05-img5.gif" width="100%" />
</p>
</div>
</div>
</div>


<div id="outline-container-org0496377" class="outline-4">
<h4 id="org0496377"><span class="section-number-4">1.1.2</span> Message Complexity</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
La message complexity del protocollo <code>Hyperflood</code> è ottima, ovvero vengono trasmessi esattamente \(n-1\) messaggi, uno per ogni nodo (sorgente esclusa).
Per dimostrarlo è necessario dimostrare che il grafo delle comunicazioni del protocollo è un <b>albero</b>, e che quindi ogni nodo non può ricevere più di una
volta lo stesso messaggio.<br />
</p>

<p>
Supponiamo per <i>assurdo</i> che esiste un nodo \(\overline{y}\) che riceve due copie del messaggio.
Se così fosse nel grafo delle comunicazioni esisterebbero due cammini <i>disgiunti</i> che da un nodo \(\overline{x}\) portano ad \(\overline{y}\).
Notare che \(\overline{x}\) potrebbe anche essere la sorgente \(\overline{s}\).
</p>


<div class="figure">
<p><img src="../images/adrc-lesson05-img6.png" alt="adrc-lesson05-img6.png" style="max-width: 200px" />
</p>
</div>


<p>
Certamente, per costruzione dell'ipercubo etichettato, i due cammini iniziano per degli archi etichettati con \(\ell_1, \ell_2\) <span class="underline">differenti</span>.
Senza perdita di generalità, assumiamo che quello di sinistra inizi con l'arco \(\ell_1\), quello destro con \(\ell_2\) e che \(\ell_1 < \ell_2\).
Sia \(\overline{x}'\) il nodo raggiunto da \(\ell_1\) e \(\overline{x}''\) quello raggiunto da \(\ell_2\).
</p>


<div class="figure">
<p><img src="../images/adrc-lesson05-img7.png" alt="adrc-lesson05-img7.png" style="max-width: 200px" />
</p>
</div>


<p>
Per costruzione, avremo che:
</p>
<ul class="org-ul">
<li>\(\overline{x}\) differisce da \(\overline{y}\) almeno per i bits in posizione \(\ell_1\) ed \(\ell_2\)</li>
<li>\(x'_{\ell_1} = y_{\ell_1}\) e \(x'_{\ell_2} \neq y_{\ell_2}\)</li>
<li>\(x''_{\ell_2} = y_{\ell_2}\) e \(x''_{\ell_1} = y_{\ell_1}\)</li>
</ul>


<div class="figure">
<p><img src="../images/adrc-lesson05-img8.png" alt="adrc-lesson05-img8.png" style="max-width: 200px" />
</p>
<p><span class="figure-number">Figura 8: </span>Esempio di una possibile situazione</p>
</div>

<p>
Importante osservare anche che entrambi i cammini, quello di sinistra e quello di destra, procedono per <b>etichette decrescenti</b>.
Ciò significa che dal cammino di sinistra verranno toccati solo nodi che differiscono da \(\overline{x}'\) per i bits con indice \(\ell_i < \ell_1\).
Questo implica che il cammino di sinistra porterà al nodo \(\overline{y}\) senza mai cambiare il bit in posizione \(\ell_2\), e questo è assurdo \(\square\).<br />
</p>
</div>
</div>


<div id="outline-container-org14a3a85" class="outline-4">
<h4 id="org14a3a85"><span class="section-number-4">1.1.3</span> Time complexity</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
Come già discusso nelle altre lezioni, ha senso parlare di time complexity solamente sotto le assunzioni di sincornismo della rete e di limitatezza nel
ritardo di trasmissione dei messaggi.
Analizziamo quindi la complessità temporale in un sistema sincrono nel quale il tempo di trasmissione vale una unità temporale.
In tale sistema con tali assunzioni la time complexity ottima, ovvero \(O(\log{n})\).<br />
</p>

<p>
La precedente affermazione si può dimostrare per induzione sulla <i>distanza di Hamming</i> dei nodi dalla sorgente.
Più in particolare si vuole dimostrare che per ogni \(j \leq d\) (dove \(d\) è la dimensione dell'ipercubo) e per ogni nodo \(x\) a distanza di Hamming
\(j\) dalla sorgente, il nodo \(x\) sarà informato al tempo \(j\).
\[
    \forall j \in \left[ d \right], \forall x \in \lbrace 0,1 \rbrace^d : d_{Ham}(s,x) = j
    \implies x \mbox{ sarà informato al tempo } j
    \]
</p>

<p>
Per \(j = 1\) questo è vero perché per definizione del protocollo la sorgente \(s\) manderà il messaggio a tutti i suoi vicini, i quali formano l'insieme
di tutti i nodi a distanza di Hamming 1 da \(s\).<br />
</p>

<p>
Per ipotesi induttiva supponiamo questo sia vero per \(j-1\), ovvero che tutti i nodi in \(L_{j-1}\) sono stati informati al tempo \(t=j-1\).
Sappiamo che per ogni nodo \(x \in L_j\) esiste sempre un cammino con tutte etichette decrescenti dalla sorgente \(s\) ad \(x\).
Dato che però le etichette sono decrescenti, allora certamente \(x\) è raggiunto da un nodo \(y\) nell'insieme \(L_{j-1}\).
Per ipotesi \(y\) è stato informato al momento \(j-1\) e inoltre il messaggio impiega un solo istante per percorrere l'arco \((y,x)\), perciò
\(x\) sarà informato al tempo \(t = (j-1) + 1 = j\) \(\square\).
</p>
</div>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Note a pi&egrave; di pagina: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
con molti archi.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
o grafo completo.
</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3">3</a></sup> <div class="footpara"><p class="footpara">
ovvero ci sarà <i>almeno</i> una coppia di nodi che non saranno reciprocamente raggiungibili.
</p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4">4</a></sup> <div class="footpara"><p class="footpara">
non è vero il contrario: se consideriamo un grafo a <i>stella</i>, il suo grado massimo è appunto massimo (\(n-1\)), però rimane comunque un grafo sparso.
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="date">Data: 2021-10-26 mar 00:00</p>
<p class="author">Autore: Alessandro Straziota</p>
<p class="email">Email: <a href="mailto:alessandrostr95@gmail.com">alessandrostr95@gmail.com</a></p>
<p class="date">Created: 2021-11-14 dom 21:57</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
