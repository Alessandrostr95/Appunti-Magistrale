<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="it" xml:lang="it">
<head>
<!-- 2022-02-18 ven 14:22 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ADRC - Lesson 24</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Alessandro Straziota" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" href="/appunti.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="/"> HOME </a>
</div><div id="content">
<h1 class="title">ADRC - Lesson 24</h1>
<div id="table-of-contents">
<h2>Indice</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org86d4745">Combinatorial Auction</a>
<ul>
<li><a href="#org39e6fa1">An efficient truthful mechanism</a></li>
<li><a href="#orgdd117b5">A greedy \(\sqrt{m}\)-approximation algorithm</a></li>
<li><a href="#org57334b7">Computing payments</a></li>
<li><a href="#orgd895f91">Fattore Approssimazione</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org86d4745" class="outline-2">
<h2 id="org86d4745">Combinatorial Auction</h2>
<div class="outline-text-2" id="text-org86d4745">
<p>
Nella <a href="./22.html">lezione 22</a> abbiamo visto il gioco dell'<i>Asta a Singolo Oggetto</i>, in cui ogni player vuole comprare l'oggetto all'asta.
Ogni player \(i\) ha una volutazione privata \(t_i\) dell'oggetto, e fa un'offerta \(r_i\) per cercare di vincere l'asta.
Se \(i\) vince allora dovrà pagare un prezzo \(p_i\), ottenendo quindi un'<i>utilità</i> pari a \(u_i = t_i - p_i\).
Abbiamo anche visto che questo è un <b>problema utilitario</b> e che quindi è sempre possibile definire un <i>meccanismo truthful</i>
che induca tutti i player a dichiarere il prorpio tipo privato \(t_i\).<br />
</p>

<p>
Il gioco dell' <b>Asta Combinatorica</b>, o <b>Combinatorial Auction</b> (in breve <code>CA</code>), è una <i>generalizzazione</i> dell'asta a singolo oggetto.
</p>

<p>
Abbiamo un'insieme di \(n\) acquirenti/player e \(m\) oggetti all'asta.
Ogni player \(i\) desidera ottenere un sottoinsieme \(S_i \subseteq \lbrace 1, ..., m \rbrace\) degli oggitti all'asta, è come <i>tipo privato</i>
ha la stima \(t_i\) di quanto vale l'insieme \(S_i\).<br />
</p>

<p>
Si desidera identificare un sottoinsieme \(W \subseteq \lbrace 1, ..., n \rbrace\) di vincitori, ognuno dei quali non va in conflitto con gli
oggetti desiderati dagli altri, ovvero
\[
  \forall i,j \in W : i \neq j \left[ S_i \cap S_j \equiv \emptyset \right]
  \]
</p>

<p>
Come nell'asta singola, si desidera <b>massimizzare</b> il <i>valore</i> di \(W\), ovvero la somma di tutti i tipi privati \(\sum_{i \in W} t_i\).<br />
</p>

<p>
Se un player \(i\) vince, allora avrebbe un guadagno pari al valore che lui stima per \(S_i\).
Più formalmente la <b>valutazione</b> \(v_i\) di ogni player sarà
\[
  v_i(t_i, W) = \begin{cases}
    t_i &\mbox{se } i \in W\\
    0 &\mbox{altrimenti}
  \end{cases}
  \;\; \forall W \in F
  \]
È facile a questo punto osservare che anche l'asta combinatorica è un gioco <i>utilitario</i>.
\[
  \sum_{i \in W} t_i = \sum_{i = 1}^{n} v_i(t_i, W) \;\;\; \forall W \subseteq \left[ n \right]
  \]
</p>

<p>
A questo punto basterà applicare il meccanismo <code>VCG</code>:
\[ g(r) = arg \max_{W \subseteq \left[ n \right]} \sum_{i = 1}^{n} v_i(t_i, W) \]
\[ p_i(r) = \sum_{j \neq i} v_j(r_j, g(r_{-i})) - \sum_{j \neq i} v_j(r_j, g(r)) \]
</p>

<p>
Constatato che il gioco <code>CA</code> è utilitario e che l'algoritmo \(g\) calcola una soluzione ottima, ci si può chiedere quanto è effettivamente complesso
(in termini computazionali) calcolare un outcome di \(g\).
</p>

<blockquote>
<p>
<b>THM</b><br />
Consideriamo il gioco <code>CA</code> con \(m\) oggetti ed \(n\) players.
Approssimare una soluzione ottima calcolata da \(g\) di un fattore <span class="underline">migliore</span> di \(m^{1/2 - \varepsilon}\) è <b>NP-Hard</b>, per ogni costante \(\varepsilon > 0\).
</p>
</blockquote>

<blockquote>
<p>
<b>Proof:</b> Il teorema verrà dimostrato mostrando una riduzione polinomiale dal problema <i>Maximum Independent Set</i> (<code>MAX-IS</code>).
</p>

<p>
Dato un grafo con \(n\) nodi, dal <i>teorema di J.Håstad, 2002</i> sappiamo che approssimare <code>MAX-IS</code> di un fattore migliore \(n^{1-\varepsilon}\) è NP-Hard.<br />
</p>

<p>
Prendiamo un'istanza \(G=(V,E)\) di <code>MAX-IS</code>, e per ogni arco associamo un oggetto all'asta, mentre per ogni nodo associamo un player.
Poniamo poi per ogni player \(i\) l'insieme \(S_i\) pari all'insieme dei suo <i>archi incidenti</i>, e \(t_i = 1\).<br />
</p>

<p>
È possibile dimostrare che un'istanza di <code>CA</code> (ricavata col metodo appena descritto) ha una soluzione di valore \(\geq k\) <span class="underline">se e solo se</span> la relativa istanza
di <code>MAX-IS</code> ha un independent set di dimensione \(\geq k\).<br />
</p>

<dl class="org-dl">
<dt>\(\Rightarrow\)</dt><dd>Supponiamo di avere una soluzione \(W\) di valore \(k\) per l'istanza di <code>CA</code>.
Dato che \(W\) è una soluzione ammissibile, allora per definizione non ci saranno due player \(i, j \in W\) che condivideranno qualche oggetto, ovvero \(S_i cap S_j \equiv \emptyset\).
Però \(S_i\) ed \(S_j\) rappresentano gli archi incidenti ai rispettivi nodi \(i\) e \(j\) dell'instanza di <code>MAX-IS</code>, e visto che non si intersecano allora certamente \(i\) e \(j\) non saranno vicini.
Perciò, dato che il valore di ogni \(S_i\) è pari a \(t_i = 1\), avremo che \(W\) è anche un independent set grande \(k\) per \(G\).<br /></dd>

<dt>\(\Leftarrow\)</dt><dd>Supponiamo ora di avere un independent set \(I\) grande \(k\) per l'istanza \(G\) di <code>MAX-IS</code>.
Per definizione, per ogni coppia di nodi \(i, j \in I\) essi non sono nodo adiacenti, perciò i rispettivi insiemi di archi incidenti non si intersecano.
Dato però che i rispettivi archi incidenti compongono gli insiemi \(S_i\) ed \(S_j\), avremo che \(S_i \cap S_j \equiv \emptyset\).
Perciò \(I\) è anche una soluzione di valore \(k\) per l'istanza di <code>CA</code>.</dd>
</dl>

<p>
Perciò consideriamo una soluzione \(W\) per <code>CA</code> di dimensione \(k\), con \(k\) sufficientemente grande in modo tale da ottenere
\[
  \frac{OPT_{\texttt{CA}}}{k} \leq m^{1/2 - \varepsilon}
  \]
</p>

<p>
Ciò implica che esiste un independent set \(I\) di cardinalità \(k\) tale che
\[
  \frac{OPT_{\texttt{MAX-IS}}}{k} = \frac{OPT_{\texttt{CA}}}{k} \leq m^{1/2 - \varepsilon} \leq n^{1 - 2\varepsilon}
  \]
dove l'ultima uguaglianza è data dal fatto che \(m \leq n^2\).<br />
</p>

<p>
Perciò se avessimo un algoritmo che riesce a calcolare \(W\) in tempo efficiente, allora avremo anche un modo di approssimare <code>MAX-IS</code> in maniera efficiente a un fattore
più piccolo di n<sup>1 - 2&epsilon;</sup> \(\square\).
</p>
</blockquote>
</div>

<div id="outline-container-org39e6fa1" class="outline-3">
<h3 id="org39e6fa1">An efficient truthful mechanism</h3>
<div class="outline-text-3" id="text-org39e6fa1">
<p>
È possibile dimostrare che il problema <code>CA</code> è anche un problema <b>one-parameter</b> (<code>OP</code>), più precisamente del tipo <b>binary-demand</b> (<code>BD</code>).<br />
</p>

<p>
Certamente i tipi privati sono un <i>singolo paramentro</i> \(t_i \in \mathbb{R}\).
Inoltre ponendo la funzione di carico di lavoro su valori binari \(w_i(\cdot) \in \lbrace 0, 1 \rbrace\) otterremo che la valutazione sarà
\[
   v_i(t_i, x) = t_i \cdot w_i(x) = \begin{cases}
   t_i &\mbox{se } i \in x\\
   0 &\mbox{altrimenti}
   \end{cases}
   \;\;\; \forall x \in F
   \]
ergo <code>CA</code> è anche un gioco <code>OP</code>.<br />
</p>

<p>
Nella <a href="./23.html">lezione precedente</a> abbiamo visto i meccanismi one-parameter per problemi di <i>minimizzazione</i>.
In questo caso il problema è di <i>massimizzazione</i>, perciò la monotonia dell'algoritmo \(g\) deve essere in non decrescente,
ovvero:
</p>

<blockquote>
<p>
per ogni player \(i\) e per ogni configurazione di strategie degli altri player \(r_{-i} = (r_1, ..., r_{i-1},r_{i+1}, ..., r_n)\)
la funzione di carico di lavoro \(w_i(r_{-i}, r_i)\) deve essere <span class="underline">non decrescente</span> al crescere del valore dichiarato \(r_i\),
ovvero della froma
</p>


<div class="figure">
<p><img src="../images/adrc-lesson24-img1.png" alt="adrc-lesson24-img1.png" style="max-width:350px; width:100%" />
</p>
<p><span class="figure-number">Figura 1: </span>Funzione di carico di lavoro \(w_i\) per un problema <i>binary demand</i> di <span class="underline">massimizzazione</span>.</p>
</div>
</blockquote>

<p>
Sappiamo già che lo schema di pagamenti del player \(i\) sarà una quantità \(p_i(r) = \theta_i(r_{-i})\).
Ciò che manca per concludere la definizione di un meccanismo truthful è la definizione di algorimo \(g\) che sia <b>monotono</b>,
che <b>approssimi</b> bene una soluzione ottima e che sia calcolabile in tempo <b>polinomiale</b>.<br />
</p>
</div>
</div>

<div id="outline-container-orgdd117b5" class="outline-3">
<h3 id="orgdd117b5">A greedy \(\sqrt{m}\)-approximation algorithm</h3>
<div class="outline-text-3" id="text-orgdd117b5">
<blockquote>
<p>
<b>Alg</b><br />
</p>
<dl class="org-dl">
<dt>Input</dt><dd>Una serie di <i>tipi dichiarati</i> \(r_1, r_2, ..., r_n\) e una serie rispettivi insiemi desiderati \(S_1, S_2, ..., S_n \subseteq \left[ m \right]\).</dd>
<dt>Output</dt><dd>Un sottoinsieme \(W \subseteq \left[ n \right]\) di vincitori dell'asta con insiemi non in conflitto.
Ovvero per ogni \(i,j \in W\) avremo che \(S_i \cap \S_j \equiv \emptyset\).</dd>
<dt>ALG</dt><dd><ol class="org-ol">
<li>riordina (e rinomina) le offerte (i tipi dichiarati) secondi il seguente ordine
\[
	\frac{r_1}{\sqrt{\vert S_1 \vert}} \geq \frac{r_2}{\sqrt{\vert S_2 \vert}} \geq ... \geq \frac{r_n}{\sqrt{\vert S_n \vert}}
	\]</li>
<li>Poni gli insiemi \(W = \emptyset\) e \(X = \emptyset\).</li>
<li>\begin{align*}
  \texttt{for } &\texttt{i=1:n do}\\
  &\texttt{if } S_i \cap X \equiv \emptyset \texttt{ then}\\
  &\;\;\;W = W \cup \lbrace i \rbrace\\
  &\;\;\;E = E \cup S_i
\end{align*}</li>
<li>return \(W\).</li>
</ol></dd>
</dl>
</blockquote>

<blockquote>
<p>
<b>Lemma 1</b> l'algoritmo \(g\) appena descritto è <b>monotono</b>.
</p>
</blockquote>

<blockquote>
<p>
<b>Proof:</b> è sufficiente dimostrare che dato un agente \(i\) selezionato nella soluzione \(W\),
anche se esso aumenta la sua offerta lui continuerà ad essere selezionato.
Infatti, rifacendoti alla funzione di carico di lavoro dei problemi <i>binary demand</i> (come quella in Figura 1),
avremo che una volta che \(r_i\) supera la soglia \(\theta_i(r_{-i})\) i valore di \(w_i\) non decresce più (rimane fisso a 1).<br />
</p>

<p>
Osservando l'ordinamento dell'algoritmo
\[
   \frac{r_1}{\sqrt{\vert S_1 \vert}} \geq ... \geq \frac{r_i}{\sqrt{\vert S_i \vert}} \geq ... \geq \frac{r_n}{\sqrt{\vert S_n \vert}}
   \]
avremo che aumentando \(r_i\) la posizione nel raching cresce, spostandosi verso sinistra.<br />
</p>

<p>
Dato che l'algoritmo sceglie in maniera <i>greedy</i> da sinistra verso destra, avremo che se \(i\) veniva selezionato dichiarando \(r_i\), certamente continuerà ad
essere selezionato se dichiara \(r_i + k\), per qualsiasi \(k > 0\) \(\square\).
</p>
</blockquote>
</div>
</div>

<div id="outline-container-org57334b7" class="outline-3">
<h3 id="org57334b7">Computing payments</h3>
<div class="outline-text-3" id="text-org57334b7">
<p>
Abbiamo visto che i pagamenti per i giochi <code>OP</code> binary demand sono del tipo \(p_i(r) = \theta_i(r_{-i})\).
Ciò che serve sapere è come ricavare la soglia \(\theta_i(r_{-i})\).
Una volta individuato un modo per ricavare la soglia, è possibile farlo in maniera efficiente?<br />
</p>

<p>
Fissiamo un player \(i\), una configurazione di strategie \(r = (r_{-i}, r_i)\) e consideriamo sempre l'ordinamento fatto nell'algoritmo \(g\).
Vogliamo sapere quanto deve essere grande <span class="underline">almeno</span> \(r_i\) affinché nell'ordinamento \(i\) venga scelto.<br />
</p>

<p>
Certamente chi sta prima di lui nell'algoritmo viene scelto e non interferisce con \(i\).
Perciò considerimo il primo player \(j\) <b>non compatibile</b> a <span class="underline">destra</span> di \(i\) nell'ordinamento, ovvero tale che \(S_i \cap S_j \not\equiv \emptyset\).
Dato che \(j\) è incompatibile con \(i\), se \(j\) venisse scelto allora per forza \(i\) non apparterrebbe alla soluzione \(W\).<br />
</p>

<p>
Perciò affinché \(i\) venga scelto nella soluzione deve essere necessariamente vero che
\[
   \frac{r_i}{\sqrt{\vert S_i \vert}} \geq \frac{r_j}{\sqrt{\vert S_j \vert}}
   \]
ovvero la soglia di accettazione per \(i\) sarà
\[
   \theta_i(r_{-i}) = \frac{r_j}{\sqrt{\vert S_j \vert}} \sqrt{\vert S_i \vert} = r_j \frac{ \sqrt{\vert S_i \vert} }{ \sqrt{\vert S_j \vert} }
   \]
Se invece non ci sono player incompatibili con \(i\), allora certamente \(i\) verrà scelto in \(W\) e quindi avremo che \(\theta_i(r_{-i}) = 0\).<br />
</p>
</div>
</div>

<div id="outline-container-orgd895f91" class="outline-3">
<h3 id="orgd895f91">Fattore Approssimazione</h3>
<div class="outline-text-3" id="text-orgd895f91">
<blockquote>
<p>
<b>Lemma 2</b>
Sia \(OPT\) una soluzione ottima per il problema <code>CA</code>, e sia \(W\) una soluzione calcolata dall'algoritmo descritto.
Allora avremo che
\[
   \sum_{i \in OPT} r_i \leq \sqrt{m} \sum_{i \in W} r_i
   \]
ovvero l'algoritmo è \(\sqrt{m}\)-approssimante.
</p>
</blockquote>

<blockquote>
<p>
<b>Proof:</b> consideriamo un player vincente \(i \in W\).
Definiamo l'insieme
\[
   OPT_i \equiv \lbrace j \in OPT : j \geq i \land S_j \cap S_i \not\equiv \emptyset \rbrace
   \]
ovvero l'insieme di tutti i player \(j\) <b>non compatibili</b> con \(i\) rispetto all'ordinamento dell'algrotimo, e che si trovano alla sua destra.<br />
</p>

<p>
Osserviamo che
\[
   \bigcup_{i \in W} OPT_i \equiv OPT
   \]
Infatti consideriamo un player nella soluzione ottima \(j \in OPT\).
Abbiamo due casi:
</p>
<dl class="org-dl">
<dt>Caso 1</dt><dd>Se \(j\) appartiene anche alla soluzione \(W\) calcolata dall'algoritmo, allora certamente \(j \in OPT_j\).</dd>
<dt>Caso 2</dt><dd>Se invece \(j \notin W\) <span class="underline">sicuramente</span> esisterà un \(i \in W\) con \(i < j\) incompatibile (ovvero \(S_j \cap S_i \not\equiv \emptyset\)).
Infatti, l'algoritmo inserisce i player nella soluzione \(W\) in ordine dal più piccolo al più grande, e se una volta arrivato a \(j\) esso fosse <span class="underline">compatibile</span> coi precenti,
allora sarebbe stato inserito nella soluzione \(W\) (ritornando al caso 1).
Perciò necessariamente \(j \in OPT_i\).</dd>
</dl>

<p>
Per dimostrare il teorema basterà dimostrare che \(\forall i \in W\)
\[
   \sum_{j \in OPT_i} r_j \leq \sqrt{m} \; r_i
   \]
infatti se così fosse avremo che
\[
   \sum_{j \in OPT} r_j \leq \sum_{i \in W} \sum_{j \in OPT_i} r_j \leq \sum_{i \in W} \sqrt{m} \; r_i = \sqrt{m} \sum_{i \in W} r_i
   \]
</p>
<hr />
<p>
Consideriamo un \(i \in W\).
Dalla sezione precende sappiamo che per ogni \(j\) a destra di \(i\) (ovvero \(j \geq i\)), \(i\) verrà scelto dall'algoritmo se e solo se
\[
   r_i \geq r_j \frac{ \sqrt{\vert S_i \vert} }{ \sqrt{\vert S_j \vert} }
   \]
perciò viceversa
\[
   r_j \leq r_i \frac{ \sqrt{\vert S_j \vert} }{ \sqrt{\vert S_i \vert} }
   \]
e questo è anche vero per ogni \(j \in OPT_i\).<br />
</p>

<p>
Perciò avremo che per ogni \(i \in W\)
\[
     \sum_{j \in OPT_i} r_j \leq \sum_{j \in OPT_i} r_i \frac{ \sqrt{\vert S_j \vert} }{ \sqrt{\vert S_i \vert} } = \frac{ r_i }{ \sqrt{\vert S_i \vert} } \sum_{j \in OPT_i} \sqrt{\vert S_j \vert} 
   \]
Diamo ora un upperbound alla sommatoria \(\sum_{j \in OPT_i} \sqrt{\vert S_j \vert}\).<br />
</p>

<p>
La <a href="https://it.wikipedia.org/wiki/Disuguaglianza_di_Cauchy-Schwarz">disuguaglianza di Cauchy-Schwarz</a> ci dice che dati due vettori \(n\)-dimensionali \(x,y\) è vero che
\[
   \left( \sum_{j = 1}^{n} x_i y_i \right) \leq \left( \sum_{j = 1}^{n} x_i^2 \right)^{1/2} \left( \sum_{j = 1}^{n} y_i^2 \right)^{1/2}
   \]
Nel nostro caso ponendo \(x_j = 1\), \(y_j = \sqrt{\vert S_j \vert}\) ed \(n = \vert OPT_i \vert\) otterremo che
</p>
\begin{align*}
  \sum_{j \in OPT_i} \sqrt{\vert S_j \vert} &= \sum_{j = 1}^{\vert OPT_i \vert} 1 \cdot \sqrt{\vert S_j \vert} \leq \left( \sum_{j = 1}^{\vert OPT_i \vert} 1 \right)^{1/2} \left( \sum_{j = 1}^{\vert OPT_i \vert} \vert S_j \vert \right)^{1/2}\\
  \\
  &= \sqrt{\vert OPT_i \vert} \cdot \sqrt{ \sum_{j = OPT_i} \vert S_j \vert }
\end{align*}

<p>
Per quanto riguarda \(\vert OPT_i \vert\) ci potrà essere <span class="underline">al più</span> un altro player \(j\) per ogni oggetto desiderato da \(i\) in \(S_i\).
Perciò \(\vert OPT_i \vert \leq \vert S_i \vert\).<br />
</p>

<p>
Invece per \(\sum_{j = OPT_i} \vert S_j \vert\), dato che tutti i \(j\) appartengono alla soluzione \(OPT\), certamente saranno tutti <span class="underline">compatibili</span> tra di loro, e quindi
\[
   \sum_{j = OPT_i} \vert S_j \vert\ = \vert \bigcup_{j \in OPT_i} S_j\vert
   \]
Infine dato che
\[
   \bigcup_{j \in OPT_i} S_j \subseteq \bigcup_{j \in OPT} S_j \subseteq \left[ m \right]
   \]
possiamo concludere che \(\sum_{j = OPT_i} \vert S_j \vert \leq m\).<br />
</p>

<p>
Ricapitolando abbiamo dimostrato che
\[
   \sum_{j \in OPT_i} \sqrt{\vert S_j \vert} \leq \sqrt{\vert OPT_i \vert} \cdot \sqrt{ \sum_{j = OPT_i} \vert S_j \vert } \leq \sqrt{\vert S_i \vert} \cdot \sqrt{m}
   \]
\[
   \implies \sum_{j \in OPT_i} r_j \leq \frac{ r_i }{ \sqrt{\vert S_i \vert} } \sum_{j \in OPT_i} \sqrt{\vert S_j \vert} \leq \frac{ r_i }{ \sqrt{\vert S_i \vert} } \sqrt{\vert S_i \vert} \cdot \sqrt{m} = \sqrt{m} \cdot r_i
   \]
\[
   \implies \sum_{j \in OPT} r_j \leq \sum_{i \in W} \sum_{j \in OPT_i} r_j \leq \sqrt{m} \sum_{i \in W} r_i \;\;\; \square
   \]
</p>
</blockquote>
<hr />
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Data: 2022-01-13 gio 00:00</p>
<p class="author">Autore: Alessandro Straziota</p>
<p class="email">Email: <a href="mailto:alessandrostr95@gmail.com">alessandrostr95@gmail.com</a></p>
<p class="date">Created: 2022-02-18 ven 14:22</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
