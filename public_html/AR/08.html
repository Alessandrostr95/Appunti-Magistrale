<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="it" xml:lang="it">
<head>
<!-- 2021-11-27 sab 00:00 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>AR - Lesson 08</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Alessandro Straziota" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" href="/appunti.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2020 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href=""> UP </a>
 |
 <a accesskey="H" href="/"> HOME </a>
</div><div id="content">
<h1 class="title">AR - Lesson 08</h1>
<div id="table-of-contents">
<h2>Indice</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org95261b2">1. Metodi euristici per partizionare in comunità</a>
<ul>
<li><a href="#org7234dd3">1.1. Edge-Betweenness</a></li>
<li><a href="#org2017b08">1.2. Il metodo di Girvan-Newman</a></li>
<li><a href="#org8adb2a4">1.3. Algoritmo per il calcolo della betweenness</a>
<ul>
<li><a href="#orgc6d5191">1.3.1. Fase 1</a></li>
<li><a href="#orgfcdace1">1.3.2. Fase 2</a></li>
<li><a href="#org7889fc5">1.3.3. Fase 3</a></li>
<li><a href="#org5d5c5b4">1.3.4. Fase 4 - Calcolo Betweenness</a></li>
</ul>
</li>
<li><a href="#orgaa6ccfc">1.4. Rilassare il modello</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org95261b2" class="outline-2">
<h2 id="org95261b2"><span class="section-number-2">1</span> Metodi euristici per partizionare in comunità</h2>
<div class="outline-text-2" id="text-1">
<p>
Nella precedente <a href="./07.html">parte</a> sono stati introdotti i concetti cut- e web-community, e dimostrato che il problema del partizionamento di un grafo
in web-communities è un problema <b>difficile</b><sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup> dal punto di vista computazionale.<br />
In questa parte verranno mostrate due famiglie approcci che dal punto di vista euristico riescono a partizionare un grafo in comunità accettabili,
ovvero in gruppi di nodi abbastanza coesi tra di loro.<br />
</p>

<p>
Più precisamente i due metodi si dividono in:
</p>
<ul class="org-ul">
<li><b>metodi partitivi</b>, in cui si parte considerando l'intero grafo come unica grande comunità, e la si inizia a disconnettere (rimuovendo archi) finché non
si otterranno due comunità distinte e coese.
Se si desidera ottenere una <i>granularità</i> maggiore basta iterare il metodo sui sottografi ottenuti.</li>
<li><b>metodi agglomerativi</b>, in cui si parte considerando ogni singolo nodo una comunità, e man mano si aggiungono gli archi del grafo finché non si otterranno
un numero di comunità desiderato con un livello di coesione accettabile.</li>
</ul>

<p>
Osservare che entrambi i metodi consentono di ottenere delle <b>partizioni nidificate</b> (<b>nested</b>), infatti nel metodo partitivo si genera una partizione
a partire da una più grande (approccio <b>top-down</b>), e nel metodo agglomerativo si genera una partizione come composizione di altre più piccole (approccio <b>bottom-up</b>).
</p>


<div class="figure">
<p><img src="../images/ar-lesson08-img1.png" alt="ar-lesson08-img1.png" style="max-width:350px;" width="100%" />
</p>
<p><span class="figure-number">Figura 1: </span>Schema di partizione metodo partitivo.</p>
</div>


<div class="figure">
<p><img src="../images/ar-lesson08-img2.png" alt="ar-lesson08-img2.png" style="max-width:350px;" width="100%" />
</p>
<p><span class="figure-number">Figura 2: </span>Schema di partizione metodo agglomerativo.</p>
</div>

<p>
Entrambi i metodi hanno quindi uno <i>schema di partizione</i> ad albero.<br />
</p>

<p>
Osservare infine che entrambi i metodi richiedono la scelta di un arco da rimuovere o aggiungere ad ogni passo.
</p>
</div>

<div id="outline-container-org7234dd3" class="outline-3">
<h3 id="org7234dd3"><span class="section-number-3">1.1</span> Edge-Betweenness</h3>
<div class="outline-text-3" id="text-1-1">
<p>
Il concetto di <b>betweennes</b> di un arco è sfruttato come criterio di rimozione degli archi nei metodi partitivi di partizionamento precedentemente accennati.
Tale concetto a sua volta si basa sulle proprietà di un arco di essere <i>bridge</i> o <i>local bridge</i>.
Sappiamo che per definizione, rimuovere un arco bridge disconnette due porzioni di una rete, mentre rimuovere un local bridge certamente peggiora la connettività tra due comunità.<br />
</p>

<p>
Sappiamo anche che gli archi bridge e local brdige sono dei <i>weak ties</i>.
Perciò, rimuovendo tutti i weak ties da una rete rimangono solamente gruppi di nodi connessi da relazioni forti (<i>strong ties</i>), e tali gruppi rispecchiano il concetto intuitivo
di comunità (ovvero gruppi di persone collegati da legami forti).<br />
</p>

<p>
Purtroppo però esistono casi in cui anche rimuovendo tutti i weak ties non avviene un partizionamento in comunità.
</p>


<div class="figure">
<p><img src="../images/ar-lesson08-img3.png" alt="ar-lesson08-img3.png" style="max-width:350px;" width="100%" />
</p>
<p><span class="figure-number">Figura 3: </span>Controesempio: in blu i weak ties e in rosso gli strong ties.</p>
</div>

<p>
Infatti, considerando il precedente controesempio, pur rimuovendo l'arco rosso non avremo un partizionamento.
Invece è evidente che c'è una comunità composta da una clique a destra e una composta da una clique a sinistra.
Per quanto riguarda il nodo centrale esso può essere inserito indistintamente i una delle due comunità.<br />
</p>

<p>
Perciò come criterio potremmo considerare la quantità di <b>traffico</b> (o <b>flusso</b>) di informazioni che passa attraverso gli archi.
Possiamo considerare come "nuovi archi ponte" tutti quegli archi attraverso i quali passa una grande quantità di flusso, e che se rimossi rendono più difficile la comunicazione tra due comunità.
Secondo questo criterio possiamo rimuovere gli archi sui quali passa maggior flusso, finché non otterremo un partizionamento accettabile della rete.<br />
</p>

<p>
Più formalmente, considerando un grafo <span class="underline">non diretto</span> \(G = (V,E)\), definiamo con \(\sigma_{st}(u,v)\) il numero di <i><a href="https://en.wikipedia.org/wiki/Shortest_path_problem">shortest-paths</a></i> \(\pi^\star(s,t)\) (o <i>camminimi minimi</i>) tra \(s\) e \(t\) che passano per l'arco \((u,v)\).<br />
</p>

<p>
Definiamo poi con \(b_{st}(u,v)\) la <b>betweennes dell'arco</b> \((u,v)\) <b>rispetto alla coppia</b> \(s,t\) come la <span class="underline">frazione</span> di shortest path \(\pi^\star(s,t)\) che passano per l'arco \((u,v)\)
</p>
\begin{align*}
  \sigma_{st} &= \vert \lbrace \pi^\star(s,t)  \rbrace \vert\\
  b_{st}(u,v) &= \frac{\sigma_{st}(u,v)}{\sigma_{st}}
\end{align*}

<p>
Definiamo infine la <b>betweenness</b> \(b(u,v)\) di un arco \((u,v)\) come la semi-somma di tutte le betweenness relative \(b_{st}(u,v)\), per ogni coppia di nodi \(s,t\)
\[
   b(u,v) = \frac{1}{2} \sum_{(s,t) \in \binom{V}{2}} b_{st}(u,v)
   \]
</p>

<p>
Notare che il fattore \(1/2\) è necessario per evitare di contare le ripetizioni, del tipo \(b_{st}(u,v)\) e \(b_{ts}(u,v)\).<br />
</p>

<p>
Analogamente alla <b>edge-betweenness</b> si può definire una <b>node-betweenness</b>, seguendo la stessa definizione.
</p>
</div>
</div>

<div id="outline-container-org2017b08" class="outline-3">
<h3 id="org2017b08"><span class="section-number-3">1.2</span> Il metodo di Girvan-Newman</h3>
<div class="outline-text-3" id="text-1-2">
<p>
Il metodo di <i>Girvan-Newman</i> è un metodo partitivo per il partizionamento, basato sul concetto di <i>edge-betweenness</i>, abbastanza semplice.
I passaggi sono i seguenti:
</p>
<ol class="org-ol">
<li>Si calcola l'arco \((u,v)\) con betweenness \(b(u,v)\) <span class="underline">massima</span>, e lo si rimuove.</li>
<li>Se il grafo residuo risulta partizionato con in una granularità desiderata allora abbiamo concluso.</li>
<li>Se così non fosse si ricalcola il nuovo arco con betweenness massima del nuovo grafo e si itera finché non si ottiene il risultato desiderato.</li>
</ol>

<p>
L'algoritmo di suo è abbastanza semplice, l'unico problema è il calcolo delle betweenness degli archi.
Purtroppo non si può applicare un approccio brute force calcolando tutti gli shortest path altrimenti la complessità risulterebbe esponenziale.
Serve quindi un approccio più efficiente.
</p>
</div>
</div>

<div id="outline-container-org8adb2a4" class="outline-3">
<h3 id="org8adb2a4"><span class="section-number-3">1.3</span> Algoritmo per il calcolo della betweenness</h3>
<div class="outline-text-3" id="text-1-3">
<p>
Per ogni nodo \(s \in V\) l'algoritmo del calcolo della betweenness degli archi si suddivide in tre fasi:
</p>
<ol class="org-ol">
<li>calcolare il sottografo \(T(s)\) composto dall'<i>unione</i> degli alberi di camminimi minimi radicati in \(s\).
Anche se il numero di tali alberi può essere esponenziale, in realtà il calcolo di \(T(s)\) può essere effettuato in tempo polinomiale con una visita in ampiezza <code>BFS</code> con le dovute modifiche.</li>
<li>Mediante una visita <code>top-down</code> calcolo i valori \(\sigma_{sv}\) per ogni \(v \in V \setminus \lbrace s \rbrace\), e questo vedremo si può fare in tempo polinomiale.</li>
<li>Infine mediante una visita <code>bottom-up</code>, e grazie a quanto calcolato nel punto 2, calcolo per ogni arco \((u,v) \in T(s)\) tutte le betweennes relative a shortest paths che partono da \(s\), ovvero il valore
\[
      b_s(u,v) = \sum_{t \in V \setminus \lbrace s \rbrace} b_{st}(u,v) \;\; \forall (u,v) \in T(s)
      \]</li>
</ol>

<p>
Per concludere, una volta eseguiti i punti <code>1-2-3</code> per ogni nodo \(s \in V\), possiamo ricavare i valori delle betweenness come segue
\[
   b(u,v) = \frac{1}{2} \sum_{s \in V} b_s(u,v)
   \]
</p>

<p>
Osserviamo che nel punto <code>3</code> calcoliamo \(b_s(u,v)\) solo per gli archi di \(T(s)\), in quanto se \((u,v)\) non appartiene al sottografo degli shortest path \(T(s)\) allora vuol dire che non appartiene
nessun shortest path, e quindi non avrebbe senso calcolarlo (per definizione di betweenness).<br />
</p>

<p>
Andiamo ora a vedere un esempio pratico che mostra anche come eseguire i tre passi dell'algoritmo del calcolo della betweenness
</p>
</div>

<div id="outline-container-orgc6d5191" class="outline-4">
<h4 id="orgc6d5191"><span class="section-number-4">1.3.1</span> Fase 1</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
Per calcolare \(T(s)\) basta effettuare una visita in ampiezza <code>BFS</code> opportunamente modificata.<br />
</p>

<p>
Definiamo con \(L_h\) l'insieme di tutti i nodi a distanza \(h\) dalla sorgente \(s\).
Diremo che un nodo \(v\) si trova al <i>livello</i> \(h\) se \(v \in L_h\).<br />
</p>

<p>
Se un nodo \(v\) si trova al livello \(h\), allora certamente <span class="underline">tutti</span> i cammini minimi da \(s\) a \(v\) termineranno con archi che partono da \(L_{h-1}\).
Perciò, tutti gli archi \((u,v)\) con \(u \in L_{h-1}\) e \(v \in L_h\) faranno parte di \(T(s)\).<br />
</p>

<p>
Perciò possiamo calcolare \(T(s)\) nella seguente maniera:
</p>
<ol class="org-ol">
<li>Poniamo inizialmente \(L_0 = \lbrace s \rbrace\) e \(T(s) = \emptyset\).</li>
<li>Per ogni \(h \geq 0\) calcoliamo \(L_{h+1}\) come tutti quei nodi <span class="underline">fuori</span> \(L_0 \cup L_1 \cup ... \cup L_h\) tali che hanno almeno un vicino in \(v \in L_h\), ovvero come
\[
       L_{h+1} \equiv \lbrace v \in V \setminus (L_0 \cup L_1 \cup ... \cup L_h) | \exists u \in L_h : (u,v) \in E  \rbrace
       \]</li>
<li>Calcolato \(L_{h+1}\) poniamo \(T(s)\) come
\[
       T(s) = T(s) \cup \lbrace (u,v) \in E | u \in L_h \land v \in L_{h+1} \rbrace
       \]</li>
</ol>


<div class="figure">
<p><img src="../images/ar-lesson08-img4.png" alt="ar-lesson08-img4.png" style="max-width:400px;" width="100%" />
</p>
<p><span class="figure-number">Figura 4: </span>Costruzione sottografo dei cammini minimi.</p>
</div>
</div>
</div>


<div id="outline-container-orgfcdace1" class="outline-4">
<h4 id="orgfcdace1"><span class="section-number-4">1.3.2</span> Fase 2</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
Calcolato \(T(s)\), possiamo sfruttarlo per calcolare, per ogni \(v \in V\), la quantità \(\sigma_{sv}\), ovvero il numero di cammini minimi che vanno da \(s\) a \(v\).<br />
</p>

<p>
Iniziamo osservando che per ogni nodo \(v\) nel livello 1, il numero di cammini minimi sarà pari ad 1 (perché \(v\) è diretto vicino di \(s\)).
Invece al livello 2, il numero di cammini minimi di un generico nodo \(v \in L_2\) è pari alla somma di tutti i \(\sigma_{su}\), tali che esiste \((u,v)\) con \(u \in L_1\).
Più in generale, per ogni \(v \in L_h\), possiamo calcolare \(\sigma_{sv}\) con la seguente formula ricorsiva
</p>
\begin{align*}
  \sigma_{sv} &= 1  &h = 1\\
  \sigma_{sv} &= \sum_{u \in N(v) \cap L_{h-1}} \sigma_{su}  &h > 1
\end{align*}


<div class="figure">
<p><img src="../images/ar-lesson08-img5.png" alt="ar-lesson08-img5.png" style="max-width:550px;" width="100%" />
</p>
<p><span class="figure-number">Figura 5: </span>Calcolo numero dei cammini minimi.</p>
</div>

<p>
Notare che questa fase viene eseguita facendo una visita <code>top-down</code> del sottografo \(T(s)\).
</p>
</div>
</div>

<div id="outline-container-org7889fc5" class="outline-4">
<h4 id="org7889fc5"><span class="section-number-4">1.3.3</span> Fase 3</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
Nella terza fase dobbiamo calcolare per ogni arco \((u,v) \in T(s)\) la quantità di flusso che ci passa sopra rispetto a \(s\), ovvero
\[
    b_s(u,v) = \sum_{t \in V \setminus \lbrace s \rbrace} b_{st}(u,v)
    \]
Per fare ciò in questo caso faremo una visita <code>bottom-up</code> di \(T(s)\).<br />
</p>

<p>
Sia \(d\) il numero di livelli in \(T(s)\), e consideriamo un arco \((y,x)\) con \(y \in L_{d-1}\) e \(x \in L_d\).
Osserviamo che tutti gli shortest path che partono da \(s\) e passano attravero l'arco \((y,x)\) sono tutti shortest path che terminano in \(x\).<br />
</p>

<p>
Perciò il flusso che passa su \((y,x)\) rispetto a \(s\) sarà pari al rapporto tra il numero di shortest path che vanno da \(s\) a \(y\) (ovvero \(\sigma_{sy}\))
e il numero complessivo di shortest path che vanno da \(s\) ad \(x\) (ovvero \(\sigma_{sx}\)).
\[
    b_s(y,x) = \sum_{t \in V \setminus \lbrace s \rbrace} b_{st}(y,x) = b_{sx}(y,x) = \frac{\sigma_{sx}(y,x)}{\sigma_{sx}} = \frac{\sigma_{sy}}{\sigma_{sx}}
    \]
</p>

<p>
Analogamente possiamo applicare questo ragionamento per tutti gli archi che collegano nodi dell'ultimo livello, come mostrato nella seguente figura.
</p>


<div class="figure">
<p><img src="../images/ar-lesson08-img6.png" alt="ar-lesson08-img6.png" style="max-width:550px;" width="100%" />
</p>
<p><span class="figure-number">Figura 6: </span>Calcolo di \(b_s(y, x)\).</p>
</div>

<p>
Adesso, saliamo di un livello, e consideriamo gli archi che entrano nel livello \(L_{d-1}\).
Rifacendoci all'immagine in esempio, consideriamo l'arco \((z, y)\), con \(z \in L_{d-2}\) e \(y \in L_{d-1}\).
</p>


<div class="figure">
<p><img src="../images/ar-lesson08-img7.png" alt="ar-lesson08-img7.png" style="max-width:300px;" width="100%" />
</p>
<p><span class="figure-number">Figura 7: </span>Esempio da considerare.</p>
</div>

<p>
Osserviamo che tra tutti i cammini minimi che passano per l'arco \((z, y)\), una parte saranno cammini che termineranno in \(y\), e una parte saranno cammini minimi che andranno ai nodi di livello inferiore.<br />
</p>

<p>
Perciò la frazione di shortest path che, partendo da \(s\), passano per \((z, y)\) è pari alla somma dei seguenti fattori:
</p>
<ul class="org-ul">
<li>La frazione degli shortest path da \(s\) ad \(y\), ovvero \(\frac{\sigma_{sz}}{\sigma_{sy}}\).</li>
<li>Per ogni <i>diretto discendente</i><sup><a id="fnr.2" class="footref" href="#fn.2">2</a></sup> \(x\) di \(y\), una frazione \(\frac{\sigma_{sz}}{\sigma_{sy}}\) della frazione di shortest path da \(s\) ad \(x\) che passano per l'arco \((y,x)\), ovvero \(\frac{\sigma_{sz}}{\sigma_{sy}} \cdot \frac{\sigma_{sy}}{\sigma_{sx}} = \frac{\sigma_{sz}}{\sigma_{sx}}\).</li>
</ul>

<p>
Quindi, rifacendoci all'esempio, avremo che
\[
    b_s(z,y) = \frac{\sigma_{sz}}{\sigma_{sy}} + \frac{\sigma_{sz}}{\sigma_{sy}} \cdot \frac{\sigma_{sy}}{\sigma_{sx}} = \frac{1}{3} + \frac{1}{3}\cdot\frac{3}{5} = \frac{8}{15}
    \]
</p>

<p>
Così facendo abbiamo definito un metodo <code>bottom-up</code> per il calcolo tutti i valori \(b_s(u,v)\).
</p>


<div class="figure">
<p><img src="../images/ar-lesson08-img8.png" alt="ar-lesson08-img8.png" style="max-width:550px;" width="100%" />
</p>
<p><span class="figure-number">Figura 8: </span>Calcolo di tutti i valori \(b_s(u, v)\).</p>
</div>
</div>
</div>


<div id="outline-container-org5d5c5b4" class="outline-4">
<h4 id="org5d5c5b4"><span class="section-number-4">1.3.4</span> Fase 4 - Calcolo Betweenness</h4>
<div class="outline-text-4" id="text-1-3-4">
<p>
Concludendo, possiamo calcolare la betweennes di tutti gli archi come già descritto in precedenza
\[
    b(u,v) = \frac{1}{2} \sum_{s \in V} b_s(u,v)
    \]
</p>

<p>
Notiamo che questa procedura permette di calcolare la betweennes degli archi in tempo <i>polinomiale</i> nella grandezza della rete (e non esponenziale).
Infatti la fase <code>1</code> è una semplice visita in ampiezza del grafo (e si può calcolare in tempo \(O(|V| + |E|)\)), la fase <code>2</code> è un'ulteriore visita in ampiezza di \(T(s)\) (e si può calcolare ancora in tempo \(O(|V| + |E|)\)),
e infine la fase <code>3</code> è nuovamente una visita in ampiezza, partendo però dal livello più basso (acnora una volta \(O(|V| + |E|)\)).<br />
</p>

<p>
Dato che bisogna iterare questo procedimento per ogni nodo del grafo, e dato che nel caso peggiore abbiamo grafi molto densi con \(\Theta(n^2)\) archi, la complessità temporale dell'esecuzione di questo
algoritmo per il calcolo delle betweennes sarà \(O(nm) \in O(n^3)\).<br />
</p>
</div>
</div>
</div>

<div id="outline-container-orgaa6ccfc" class="outline-3">
<h3 id="orgaa6ccfc"><span class="section-number-3">1.4</span> Rilassare il modello</h3>
<div class="outline-text-3" id="text-1-4">
<p>
<b>[DA FINIRE]</b>
</p>

<hr />
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Note a pi&egrave; di pagina: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
ovvero <b>NP-completo</b>.
</p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2">2</a></sup> <div class="footpara"><p class="footpara">
ovvero quei nodi collegati ad \(y\) da un arco e che si trovano al successivo livello più in basso.
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="date">Data: 2021-11-15 lun 00:00</p>
<p class="author">Autore: Alessandro Straziota</p>
<p class="email">Email: <a href="mailto:alessandrostr95@gmail.com">alessandrostr95@gmail.com</a></p>
<p class="date">Created: 2021-11-27 sab 00:00</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
