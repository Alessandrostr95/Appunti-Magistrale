#+options: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline
#+options: author:t broken-links:nil c:nil creator:nil
#+options: d:(not "LOGBOOK") date:nil e:t email:nil f:t inline:t num:t
#+options: p:nil pri:nil prop:nil stat:t tags:t tasks:t tex:t
#+options: timestamp:t title:t toc:t todo:t |:t
#+title: ADRC - Lesson 07
#+date: <2021-10-28 lun>
#+email: alessandrostr95@gmail.com
#+teacher: Andrea Clementi
#+language: it
#+select_tags: export
#+exclude_tags: noexport
#+creator: Emacs 27.1 (Org mode 9.4.6)
#+setupfile: ../../org-template/appunti.org


* Spanning tree construction
  Uno *spanning tree*, o *albero ricoprente*, è un sottoinsieme di archi $T \subseteq E$ tale che
  il grafo $G=(V,T)$ risulta essere *connesso* e *aciclico*.\\

  Come visto per il protocollo di broadcast, è spesso utile riuscire a calcolare uno spanning tree
  su una rete in maniera /distribuita/.
  
  La definizione di tale problema è la seguente
  - *Assunzioni*:
    - *Single initiator* esiste un solo nodo che in risposta ad uno stimolo esterno o spontaneamente avvia il protocollo.
    - *Bidirectional links* il grafo di rete è non diretto
    - *Total reliability* si ha certezza che un messaggio trasmesso su un arco arriva sempre a destinazione in un tempo finito
      e senza errori
    - *Connectivity* il grafo di rete $G$ è connesso
  - *Configurazione iniziale*: ogni nodo $x \in V$ conserva un sottoinsieme di vicini denominato con $\texttt{tree-neig}(x)$,
    che rappresenta i relativi vicini nello /spanning tree/. Inizialmente tale insieme è /inizializzato/ come vuoto $\texttt{tree-neig}(x) = \lbrace \rbrace$.
  - *Configurazione finale*: uno stato in cui tutti i nodi hanno nell'insieme $\texttt{tree-neig}(x)$ tutti e soli i nodi
    vicini nello spanning tree ricavato dal protocollo.

* Single Source Shout Protocol
  Immedesimandosi in un generico nodo $x$ ci si può chiedere:
  #+begin_quote
  come decido chi saranno i miei vicini nello spanning tree?
  #+end_quote
  Semplicemente basta /chiedere/ ai propri vicini se appartengono già allo spanning tree che si sta costruendo,
  e in base alla risposta agire di conseguenza:
  - se il nodo già appartiene allo spanning tree allora lo si scarta.
  - se il nodo ancora non appartiene allora gli si propone se vuole diventare un nodo /figlio/.
  
  In generale potrebbe capitare che un nodo riceva molteplici richieste di diventare nodo figlio, però
  semplicemente può rispondere =YES= alla prima proposta, e =NO= a tutte le altre.\\
  
  Per ridurre ulteriormente il numero di messaggi, quando il nodo $x$ diventa parte dello spanning tree,
  manda in broadcast a tutti i suoi vicini (eccetto al nodo padre) la proposta di diventare nodo figlio.\\

  #+caption: Spontaneamente la sorgente avvia il protocollo
  #+ATTR_HTML: :style max-width:200px width:100%
  [[file:../images/adrc-lesson07-img1.png]]

  #+caption: Possibili situazioni
  #+ATTR_HTML: :style max-width:400px width:100%
  [[file:../images/adrc-lesson07-img2.png]]
  
  Definiamo quindi l'insieme degli stati del processo
  \begin{align*}
  S &= \lbrace \texttt{INIT}, \texttt{IDLE}, \texttt{ACTIVE}, \texttt{DONE} \rbrace\\
  S_{init} &= \lbrace \texttt{INIT}, \texttt{IDLE} \rbrace\\
  S_{final} &= \lbrace \texttt{DONE} \rbrace
  \end{align*}

  #+begin_src python
    if self.state == "INIT":
	spontaneusly:
	    self.root = True
	    self.tree_neig = {}
	    send(Q) to self.neighbors
	    self.counter = 0
	    self.state = "ACTIVE"
    
    if self.state == "IDLE":
	receiving(Q):
	    self.root = False
	    self.parent = Q.sender
	    self.tree_neig = {Q.sender}
	    send("YES") to Q.sender
	    self.counter = 1
    
	    if self.counter == len(self.neighbors):
		self.state = "DONE"
	    else:
		send(Q) to self.neighbors - {Q.sender}
		self.state = "ACTIVE"
    
    if self.state == "ACTIVE":
	receiving(Q):
	    send("NO") to Q.sender
	receiving(R):
	
	    if R.msg == "YES":
		self.tree_neig = self.tree_neig + {R.sender}
		self.counter += 1  
	    elif R.msg == "NO":
		self.counter += 1
    
	    if self.counter == len(self.neighbors):
		    self.state == "DONE"
    
    if self.stat == "DONE":
	None
  #+end_src
  #+html: <p align="center"><span class="figure-number">Code 1:</span> Pseudocodice python-like del protocollo Shout/p>

** Terminazione del protocollo
   Il protocollo =Shout= è molto simile al protocollo =Flood=, con l'aggiunta di messaggi di /feedback/ =YES/NO=.
   Dato che siamo sotto l'assunzione che $G$ è connesso, allora certamente ogni nodo $x$ (eccetto la sorgente) riceverà almeno una richiesta =Q= di diventare figlio.
   Perciò ogni nodo nello stato =IDLE= passerà allo stato =ACTIVE=, con il proprio contatore pari a 1.
   Per _ogni richiesta_ ricevuta tutti i nodi risponderanno =YES= o =NO=.
   Dato che prima di entrare nello stato =DONE= un nodo deve ricevere una risposta da tutti i vicini, e dato che per costruizione tutti rispondono alle richieste
   allora prima o poi tutti i nodi passerranno dallo stato =ACTIVE= allo stato =DONE=, terminando localmente il proprio task.\\

** Correttezza
   Si vuole dimostrare che l'unione di tutti i $\texttt{tree-neig}(x)$ è uno /spanning tree/ per la rete $G$.\\

   Per prima cosa bisogna dimostrare le *coerenza* degli insiemi $\texttt{tree-neig}(x)$, ovvero che $x$ ha come vicino $y$ nello spanning tree ($y \in \texttt{tree-neig}(x)$)
   allora anche $x$ deve risultare essere vicino di $y$ ($x \in \texttt{tree-neig}(y)$).
   Questo è facilmente verificabile: certamente uno tra $x$ e $y$ deve necessariamente essere il nodo padre, supponiamo $x$ senza perdita di generalità.
   Dato che $y \in \texttt{tree-neig}(x)$, e dato che stiamo assumendo che $y$ è figlio di $x$, allora vuol dire che $y$ avrà risposto =YES= alla proposta di $x$, e per
   costruzione del protocollo $x$ che è nello stato =ACTIVE= aggiungerà $y$ nel suo vicinato.
   Contrariamente se $y$ ha risposto =YES= vuol dire che era nello stato =IDLE=, e che la prima richiesta ricevuta è stata quella di $x$.
   Per costruzione del protocollo, $y$ contra $x$ come nodo padre, e lo aggiungerà nel suo vicinato.\\

   A questo punto è necessario dimostrare che l'unione di tutti i $\texttt{tree-neig}(x)$ è *connesso*.
   Anche questo è banalmente verificabile dal fatto che ogni nodo $x$ (eccetto la sorgente) è collegato al proprio genitore tramite una sequenza di /YES-links/
   che risale fino alla sorgente.
   Perciò data una qualsiasi coppia di nodi $x,y$, essi saranno connessi dal cammino $x \leadsto s \leadsto y$, dove $s$ è il nodo sorgente.\\

   Infine non resta che dimostrare che il grafo risultante dal protocollo è *aciclico*.
   Questo si può inferire dal fatto che ogni nodo (eccetto la sorgente) invia *una sola* risposta =YES=, la quale permetterà al nodo di "appendersi" all'albero.
   Supponiamo quindi /per assurdo/ che da nodo $x$ esistano due cammini semplici distinti fino alla sorgente $s$ che formano un ciclo.
   Anche se i dui cammini possono iniziare "scendendo" di livello, dato che entrambi i cammini *risalgono* alla sorgente
   allora certamente da un certo punto in poi passeranno per un arco che parte da un nodo figlio verso un nodo padre salendo di livello.
   Consideriamo solo uno dei due lati del ciclo (tanto il ragionamento è simmetrico).
   Supponiamo che il primo arco del cammino che risale di livello è un certo $(a,b)$, dove $b$ è genitore di $a$.
   Dato $(a,b)$ è il primo arco /risalente/, vuol dire che prima di prendere $(a,b)$ si è scesi di livello con tutti archi del tipo =PADRE->FIGLIO=.
   Però sappiamo che ogni nodo ha un *singolo* nodo padre, perciò per arrivare ad $a$ certamente si sarà preso l'arco $(b,a)$.
   Questo però non può accadere in quanto nei cammini semplici non si può ripercorrere due volte uno stesso arco, perciò entrambi i lati dell'ipotetico ciclo
   devono necessariamente partire $x$ a *risalire*.
   Ma dato che *x* ha un solo padre allora esiste un solo cammino (/risalente/) da $x$ alla sorgente $s$.


** Message complexity
   Come accennato in precedenza il protocollo =Shout= è una sorta di protocollo =Flood= con l'aggiunta di messaggi di /feedback/.
   Perciò si può intuire che la message complexity del protocollo =Shout= è due volte quella del protocollo =Flood=.
   \[
   MSG(\texttt{SHOUT}) = 2 \cdot MSG(\texttt{FLOOD})
   \]
   Andiamo però a fare un'analisi più dettagliata per verificare l'intuizione.\\

   Consideriamo che i messaggi che passano sugli archi sono del tipo =Q=, di richiesta di diventare figlio, e di tipo =R=, di risposta, il quale a sua
   volta può essere di tipo =YES= o =NO=.
   Si vuole quindi contare per ogni tipologia di messaggi =Q=, =YES=, =NO= quanti ne vengono trasmessi per ogni arco.\\

   Iniziamo però considerando quali situazioni è possibbile che accadano e quali no:
**** *Casi possibili*
     - caso =Q-YES=, ovvero nel caso in cui su di un arco passa prima una proposta =Q= e poi la risposta =YES=.
     - caso =Q-Q=, quando due nodi vicini passano nello stato active (_quasi_) simultaneamente e si scambiano reciporcamente una proposta =Q=.
     - caso =NO-NO=, diretta conseguenza del caso precedente.
**** *Casi impossibili*
     - caso =NO-YES=, non può accadere in quanto il nodo sinistro per rispondere =NO= deve prima aver ricevuto una richiesta dal nodo destro, il quale avrà già
       un padre e quindi non può rispondere nuovamente =YES=.
     - caso =YES-YES=, per inviarsi reciprocamente il messaggio =YES=, vuol dire che entrambe le estremità dell'arco hanno inviato il messaggio =Q=, ma ciò implica
       che hanno già un padre e che quindi hanno già inviato =YES= a un altro nodo.

   #+ATTR_HTML: :style max-width:400px width:100%
   [[file:../images/adrc-lesson07-img3.png]]


   Contiamo ora quanti messaggi vengono scambiati per ogni caso possibile
**** =Q= *messages :*
     Il messaggio =Q= viene inviato nei casi =Q-YES= e =Q-Q=.
     Il caso =Q-YES= accade esattamente una volta per ogni nodo eccetto la sorgente, ovvero $n-1$ volte.
     Il caso =Q-Q= accade su tutti gli archi del vicinato di un nodo eccetto che per l'arco per il quale il nodo è diventato figlio (ovviamente escludendo la sorgente).
     Perciò avremo $m$ archi meno un arco per ogni nodo esclusa la sorgente, ovvero meno $n-1$ archi.
     Perciò in totale verranno scambiati $2(m - (n-1)) - (n-1) = 2m - n + 1$ messaggi di tipo =Q=.

     *[da finire]*
